package metadata

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"main/internal/core"
	"main/internal/utils"
	"main/utils/structs"

	"github.com/zhaarey/go-mp4tag"
)

// getQualityString determines the quality tag: RESPECT USER CHOICE FIRST, then fallback to auto-detection
func getQualityString(audioTraits []string) string {
	// Priority 1: Respect user's explicit quality choice
	if core.Dl_atmos {
		return utils.FormatQualityTag("Dolby Atmos")
	} else if core.Dl_aac && core.Aac_type != nil && *core.Aac_type == "aac-binaural" {
		return utils.FormatQualityTag("Aac Binaural")
	} else if core.Dl_aac && core.Aac_type != nil && *core.Aac_type == "aac-downmix" {
		return utils.FormatQualityTag("Aac Downmix")
	} else if core.Dl_aac && core.Aac_type != nil && *core.Aac_type == "aac-lc" {
		return utils.FormatQualityTag("Aac 256")
	} else if core.Dl_aac && core.Aac_type != nil {
		// Generic AAC mode - check if user wants specific type
		if *core.Aac_type != "aac" {
			return utils.FormatQualityTag("Aac " + strings.Title(*core.Aac_type))
		} else {
			return utils.FormatQualityTag("Aac 256")
		}
	}

	// Priority 2: Auto-detect best quality when user didn't specify
	if utils.Contains(audioTraits, "hi-res-lossless") {
		return utils.FormatQualityTag("Hi-Res Lossless")
	} else if utils.Contains(audioTraits, "lossless") {
		return utils.FormatQualityTag("Alac")
	} else if utils.Contains(audioTraits, "atmos") {
		return utils.FormatQualityTag("Dolby Atmos")
	}

	// Default to AAC
	return utils.FormatQualityTag("Aac 256")
}

func WriteCover(sanAlbumFolder, name string, url string) (string, error) {
	covPath := filepath.Join(sanAlbumFolder, name+"."+core.Config.CoverFormat)
	if core.Config.CoverFormat == "original" {
		ext := strings.Split(url, "/")[len(strings.Split(url, "/"))-2]
		ext = ext[strings.LastIndex(ext, ".")+1:]
		covPath = filepath.Join(sanAlbumFolder, name+"."+ext)
	}
	exists, err := utils.FileExists(covPath)
	if err != nil {
		return "", err
	}
	if exists {
		_ = os.Remove(covPath)
	}
	if core.Config.CoverFormat == "png" {
		re := regexp.MustCompile(`\{w\}x\{h\}`)
		parts := re.Split(url, 2)
		url = parts[0] + "{w}x{h}" + strings.Replace(parts[1], ".jpg", ".png", 1)
	}
	url = strings.Replace(url, "{w}x{h}", core.Config.CoverSize, 1)
	if core.Config.CoverFormat == "original" {
		url = strings.Replace(url, "is1-ssl.mzstatic.com/image/thumb", "a5.mzstatic.com/us/r1000/0", 1)
		url = url[:strings.LastIndex(url, "/")]
	}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	do, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		return "", errors.New(do.Status)
	}
	f, err := os.Create(covPath)
	if err != nil {
		return "", err
	}
	defer f.Close()
	_, err = io.Copy(f, do.Body)
	if err != nil {
		return "", err
	}
	return covPath, nil
}

func WriteLyrics(sanAlbumFolder, filename string, lrc string) error {
	lyricspath := filepath.Join(sanAlbumFolder, filename)
	f, err := os.Create(lyricspath)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.WriteString(lrc)
	if err != nil {
		return err
	}
	return nil
}

// fixIlstBoxMissing 使用 FFmpeg 重新封装 MP4 文件以添加缺失的 ilst box
// 参数:
//   - trackPath: 需要修复的音频文件路径
//
// 返回:
//   - error: 修复过程中的错误，成功返回 nil
func fixIlstBoxMissing(trackPath string) error {
	// 检查 ffmpeg 是否存在
	_, err := exec.LookPath("ffmpeg")
	if err != nil {
		return fmt.Errorf("未找到 ffmpeg 命令: %w", err)
	}

	// 创建临时文件路径
	tempPath := trackPath + ".tmp.m4a"

	// 使用 FFmpeg 重新封装文件，添加元数据容器
	// -i: 输入文件
	// -c copy: 复制所有流，不重新编码（快速）
	// -movflags +faststart: 优化文件结构，将 moov atom 移到文件开头
	// -f mp4: 强制输出为 MP4 格式
	cmd := exec.Command("ffmpeg", "-i", trackPath, "-c", "copy", "-movflags", "+faststart", "-f", "mp4", "-y", tempPath)

	// 捕获错误输出
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	// 执行命令
	if err := cmd.Run(); err != nil {
		// 清理临时文件
		os.Remove(tempPath)
		return fmt.Errorf("FFmpeg 重新封装失败: %w, stderr: %s", err, stderr.String())
	}

	// 检查临时文件是否创建成功
	if _, err := os.Stat(tempPath); err != nil {
		return fmt.Errorf("FFmpeg 输出文件未创建: %w", err)
	}

	// 替换原文件
	if err := os.Remove(trackPath); err != nil {
		os.Remove(tempPath)
		return fmt.Errorf("删除原文件失败: %w", err)
	}

	if err := os.Rename(tempPath, trackPath); err != nil {
		return fmt.Errorf("重命名临时文件失败: %w", err)
	}

	return nil
}

// WriteMP4TagsWithRetry 尝试写入 MP4 标签，如果遇到 ilst box 缺失错误则自动修复
// 参数与 WriteMP4Tags 相同
// 返回:
//   - error: 写入或修复过程中的错误
func WriteMP4TagsWithRetry(trackPath, lrc string, meta *structs.AutoGenerated, trackNum, trackTotal int) error {
	// 第一次尝试写入标签
	err := WriteMP4Tags(trackPath, lrc, meta, trackNum, trackTotal)

	// 如果没有错误，直接返回
	if err == nil {
		return nil
	}

	// 检查是否是 ilst box 缺失错误
	errMsg := err.Error()
	if !strings.Contains(errMsg, "ilst box not present") && !strings.Contains(errMsg, "ilst") {
		// 不是 ilst box 问题，直接返回原错误
		return err
	}

	// 尝试使用 FFmpeg 修复
	if fixErr := fixIlstBoxMissing(trackPath); fixErr != nil {
		return fmt.Errorf("ilst box 修复失败: %w (原错误: %v)", fixErr, err)
	}

	// 修复成功后重试写入标签
	retryErr := WriteMP4Tags(trackPath, lrc, meta, trackNum, trackTotal)
	if retryErr != nil {
		return fmt.Errorf("修复后标签写入仍失败: %w", retryErr)
	}

	return nil
}

func WriteMP4Tags(trackPath, lrc string, meta *structs.AutoGenerated, trackNum, trackTotal int) error {
	index := trackNum - 1

	// Get quality string for metadata embedding
	qualityString := getQualityString(meta.Data[0].Relationships.Tracks.Data[index].Attributes.AudioTraits)

	t := &mp4tag.MP4Tags{
		Title:      meta.Data[0].Relationships.Tracks.Data[index].Attributes.Name,
		TitleSort:  meta.Data[0].Relationships.Tracks.Data[index].Attributes.Name,
		Artist:     meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName,
		ArtistSort: meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName,
		Custom: map[string]string{
			"PERFORMER":   meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName,
			"RELEASETIME": meta.Data[0].Relationships.Tracks.Data[index].Attributes.ReleaseDate,
			"ISRC":        meta.Data[0].Relationships.Tracks.Data[index].Attributes.Isrc,
			"LABEL":       meta.Data[0].Attributes.RecordLabel,
			"UPC":         meta.Data[0].Attributes.Upc,
			"QUALITY":     qualityString, // Add quality tag to metadata
		},
		Composer:     meta.Data[0].Relationships.Tracks.Data[index].Attributes.ComposerName,
		ComposerSort: meta.Data[0].Relationships.Tracks.Data[index].Attributes.ComposerName,
		Date:         meta.Data[0].Attributes.ReleaseDate,
		CustomGenre:  meta.Data[0].Relationships.Tracks.Data[index].Attributes.GenreNames[0],
		Copyright:    meta.Data[0].Attributes.Copyright,
		Publisher:    meta.Data[0].Attributes.RecordLabel,
		Lyrics:       lrc,
	}

	if meta.Data[0].Attributes.EditorialNotes != nil && meta.Data[0].Attributes.EditorialNotes.Standard != "" {
		reHTML := regexp.MustCompile("<[^>]*>")
		textWithoutHTML := reHTML.ReplaceAllString(meta.Data[0].Attributes.EditorialNotes.Standard, "")
		reNewlines := regexp.MustCompile(`\n{2,}`)
		cleanComment := reNewlines.ReplaceAllString(textWithoutHTML, "\n")
		t.Comment = strings.TrimSpace(cleanComment)
	}

	if !strings.Contains(meta.Data[0].ID, "pl.") {
		albumID, err := strconv.ParseUint(meta.Data[0].ID, 10, 32)
		if err == nil && albumID <= math.MaxInt32 {
			t.ItunesAlbumID = int32(albumID)
		}
	}

	if len(meta.Data[0].Relationships.Artists.Data) > 0 {
		if len(meta.Data[0].Relationships.Tracks.Data[index].Relationships.Artists.Data) > 0 {
			artistID, err := strconv.ParseUint(meta.Data[0].Relationships.Tracks.Data[index].Relationships.Artists.Data[0].ID, 10, 32)
			if err == nil && artistID <= math.MaxInt32 {
				t.ItunesArtistID = int32(artistID)
			}
		}
	}

	if strings.Contains(meta.Data[0].ID, "pl.") && !core.Config.UseSongInfoForPlaylist {
		t.DiscNumber = 1
		t.DiscTotal = 1
		// 安全转换，防止溢出
		if trackNum <= math.MaxInt16 {
			t.TrackNumber = int16(trackNum)
		}
		if trackTotal <= math.MaxInt16 {
			t.TrackTotal = int16(trackTotal)
		}
		// 为播放列表专辑名称添加音质标签，确保音乐管理软件能识别不同音质版本
		t.Album = meta.Data[0].Attributes.Name + " " + qualityString
		t.AlbumSort = meta.Data[0].Attributes.Name + " " + qualityString
		t.AlbumArtist = meta.Data[0].Attributes.ArtistName
		t.AlbumArtistSort = meta.Data[0].Attributes.ArtistName
	} else if strings.Contains(meta.Data[0].ID, "pl.") && core.Config.UseSongInfoForPlaylist {
		discNum := meta.Data[0].Relationships.Tracks.Data[index].Attributes.DiscNumber
		if discNum <= math.MaxInt16 {
			t.DiscNumber = int16(discNum)
		}
		discTotal := meta.Data[0].Relationships.Tracks.Data[trackTotal-1].Attributes.DiscNumber
		if discTotal <= math.MaxInt16 {
			t.DiscTotal = int16(discTotal)
		}
		trackNumber := meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber
		if trackNumber <= math.MaxInt16 {
			t.TrackNumber = int16(trackNumber)
		}
		if trackTotal <= math.MaxInt16 {
			t.TrackTotal = int16(trackTotal)
		}
		// 为播放列表歌曲的原专辑名称添加音质标签
		t.Album = meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName + " " + qualityString
		t.AlbumSort = meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName + " " + qualityString
		t.AlbumArtist = meta.Data[0].Relationships.Tracks.Data[index].Relationships.Albums.Data[0].Attributes.ArtistName
		t.AlbumArtistSort = meta.Data[0].Relationships.Tracks.Data[index].Relationships.Albums.Data[0].Attributes.ArtistName
	} else {
		discNum := meta.Data[0].Relationships.Tracks.Data[index].Attributes.DiscNumber
		if discNum <= math.MaxInt16 {
			t.DiscNumber = int16(discNum)
		}
		discTotal := meta.Data[0].Relationships.Tracks.Data[trackTotal-1].Attributes.DiscNumber
		if discTotal <= math.MaxInt16 {
			t.DiscTotal = int16(discTotal)
		}
		trackNumber := meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber
		if trackNumber <= math.MaxInt16 {
			t.TrackNumber = int16(trackNumber)
		}
		if trackTotal <= math.MaxInt16 {
			t.TrackTotal = int16(trackTotal)
		}
		// 为专辑名称添加音质标签，确保音乐管理软件能识别不同音质版本
		// 示例: "Black Codes (From The Underground) [2023 Remaster] Alac"
		t.Album = meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName + " " + qualityString
		t.AlbumSort = meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName + " " + qualityString
		t.AlbumArtist = meta.Data[0].Attributes.ArtistName
		t.AlbumArtistSort = meta.Data[0].Attributes.ArtistName
	}

	if meta.Data[0].Relationships.Tracks.Data[index].Attributes.ContentRating == "explicit" {
		t.ItunesAdvisory = mp4tag.ItunesAdvisoryExplicit
	} else if meta.Data[0].Relationships.Tracks.Data[index].Attributes.ContentRating == "clean" {
		t.ItunesAdvisory = mp4tag.ItunesAdvisoryClean
	} else {
		t.ItunesAdvisory = mp4tag.ItunesAdvisoryNone
	}

	mp4, err := mp4tag.Open(trackPath)
	if err != nil {
		return err
	}
	defer mp4.Close()
	err = mp4.Write(t, []string{})
	if err != nil {
		return err
	}
	return nil
}
