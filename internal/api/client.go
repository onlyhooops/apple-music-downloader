package api

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"main/internal/core"
	"main/internal/logger"
	"main/internal/parser"
	"main/utils/structs"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
)

// GetUrlSong retrieves the full album URL for a single song URL
func GetUrlSong(songUrl string, account *structs.Account) (string, error) {
	storefront, songId := parser.CheckUrlSong(songUrl)
	manifest, err := GetInfoFromAdam(songId, account, storefront)
	if err != nil {
		logger.Error("\u26A0 Failed to get manifest: %v", err)
		core.SharedLock.Lock()
		core.Counter.NotSong++
		core.SharedLock.Unlock()
		return "", err
	}
	if len(manifest.Relationships.Albums.Data) == 0 {
		return "", fmt.Errorf("æ­Œæ›² %s ä¸å±äºä»»ä½•ä¸“è¾‘ï¼ˆå¯èƒ½æ˜¯å•ç‹¬å‘å¸ƒçš„å•æ›²ï¼‰", songId)
	}
	albumId := manifest.Relationships.Albums.Data[0].ID
	songAlbumUrl := fmt.Sprintf("https://music.apple.com/%s/album/1/%s?i=%s", storefront, albumId, songId)
	return songAlbumUrl, nil
}

// GetUrlArtistName retrieves the artist's name and ID from an artist URL
func GetUrlArtistName(urlRaw string, account *structs.Account) (string, string, error) {
	storefront, artistId := parser.CheckUrlArtist(urlRaw)
	req, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/artists/%s", storefront, artistId), nil)
	if err != nil {
		return "", "", err
	}
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	req.Header.Set("Origin", "https://music.apple.com")
	query := url.Values{}
	query.Set("l", core.Config.Language)
	req.URL.RawQuery = query.Encode()
	do, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", "", err
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("è·å–è‰ºæœ¯å®¶åç§°å¤±è´¥ (HTTP %s): URL=%s", do.Status, urlRaw)
	}
	obj := new(structs.AutoGeneratedArtist)
	err = json.NewDecoder(do.Body).Decode(&obj)
	if err != nil {
		return "", "", err
	}
	return obj.Data[0].Attributes.Name, obj.Data[0].ID, nil
}

// CheckArtist retrieves and displays albums or music videos for an artist for selection
func CheckArtist(artistUrl string, account *structs.Account, relationship string) ([]string, error) {
	storefront, artistId := parser.CheckUrlArtist(artistUrl)
	Num := 0
	var args []string
	var urls []string
	var options [][]string
	var hasMore bool = true
	for hasMore {
		apiURL := fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/artists/%s/%s?limit=100&offset=%d&l=%s", storefront, artistId, relationship, Num, core.Config.Language)
		logger.Debug("[API] è¯·æ±‚è‰ºæœ¯å®¶ API: %s", apiURL)
		logger.Debug("[API] Tokené•¿åº¦: %d", len(core.DeveloperToken))

		req, err := http.NewRequest("GET", apiURL, nil)
		if err != nil {
			return nil, err
		}
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
		req.Header.Set("Origin", "https://music.apple.com")
		do, err := http.DefaultClient.Do(req)
		if err != nil {
			return nil, err
		}

		// ä½¿ç”¨é—­åŒ…ç«‹å³å…³é—­ HTTP è¿æ¥ï¼Œé¿å…åœ¨å¾ªç¯ä¸­ç´¯ç§¯
		err = func() error {
			defer do.Body.Close()

			if do.StatusCode != http.StatusOK {
				logger.Debug("[API] CheckArtist è¯·æ±‚å¤±è´¥: HTTP %s, è‰ºæœ¯å®¶ID=%s, offset=%d", do.Status, artistId, Num)
				return fmt.Errorf("è·å–è‰ºæœ¯å®¶ä¸“è¾‘åˆ—è¡¨å¤±è´¥ (HTTP %s)", do.Status)
			}
			obj := new(structs.AutoGeneratedArtist)
			if err := json.NewDecoder(do.Body).Decode(&obj); err != nil {
				return fmt.Errorf("è§£æè‰ºæœ¯å®¶ä¸“è¾‘æ•°æ®å¤±è´¥: %w", err)
			}

			for _, album := range obj.Data {
				// å¦‚æœå¯ç”¨äº† singles-only æ¨¡å¼ï¼Œåªä¿ç•™å•æ›²ä¸“è¾‘
				if core.Dl_singles_only && relationship == "albums" {
					isSingle := album.Attributes.IsSingle ||
						strings.Contains(album.Attributes.Name, "- Single") ||
						strings.Contains(album.Attributes.Name, " Single") ||
						strings.Contains(album.Attributes.Name, "å•æ›²")
					if !isSingle {
						continue // è·³è¿‡éå•æ›²ä¸“è¾‘
					}
				}
				options = append(options, []string{album.Attributes.Name, album.Attributes.ReleaseDate, album.ID, album.Attributes.URL})
			}

			// æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€é¡µ
			if len(obj.Next) == 0 {
				logger.Debug("[API] å·²åˆ°è¾¾æœ€åä¸€é¡µï¼Œå…±è·å– %d é¡¹", len(options))
				hasMore = false
			}
			return nil
		}()

		if err != nil {
			return nil, err
		}

		Num = Num + 100
	}
	sort.Slice(options, func(i, j int) bool {
		dateI, _ := time.Parse("2006-01-02", options[i][1])
		dateJ, _ := time.Parse("2006-01-02", options[j][1])
		return dateI.Before(dateJ)
	})

	table := tablewriter.NewWriter(os.Stdout)
	if relationship == "albums" {
		table.SetHeader([]string{"", "Album Name", "Date", "Album ID"})
	} else if relationship == "music-videos" {
		table.SetHeader([]string{"", "MV Name", "Date", "MV ID"})
	}
	table.SetRowLine(false)
	table.SetHeaderColor(tablewriter.Colors{},
		tablewriter.Colors{tablewriter.FgRedColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})

	table.SetColumnColor(tablewriter.Colors{tablewriter.FgCyanColor},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgRedColor},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})
	for i, v := range options {
		urls = append(urls, v[3])
		options[i] = append([]string{fmt.Sprint(i + 1)}, v[:3]...)
		table.Append(options[i])
	}
	table.Render()
	if core.Artist_select {
		logger.Info("You have selected all options:")
		return urls, nil
	}
	// å¦‚æœå¯ç”¨äº† singles-only æ¨¡å¼ï¼Œè‡ªåŠ¨é€‰æ‹©æ‰€æœ‰å•æ›²
	if core.Dl_singles_only && relationship == "albums" {
		logger.Info("ğŸµ Singles-Only æ¨¡å¼ï¼šè‡ªåŠ¨é€‰æ‹©æ‰€æœ‰ %d ä¸ªå•æ›²", len(urls))
		return urls, nil
	}
	reader := bufio.NewReader(os.Stdin)
	logger.Info("Please select from the %s options above (multiple options separated by commas, ranges supported, or type 'all' to select all)", relationship)
	cyanColor := color.New(color.FgCyan)
	cyanColor.Print("Enter your choice: ")
	input, _ := reader.ReadString('\n')

	input = strings.TrimSpace(input)
	if input == "all" {
		logger.Info("You have selected all options:")
		return urls, nil
	}

	selectedOptions := [][]string{}
	parts := strings.Split(input, ",")
	for _, part := range parts {
		if strings.Contains(part, "-") {
			rangeParts := strings.Split(part, "-")
			selectedOptions = append(selectedOptions, rangeParts)
		} else {
			selectedOptions = append(selectedOptions, []string{part})
		}
	}

	logger.Info("You have selected the following options:")
	for _, opt := range selectedOptions {
		if len(opt) == 1 {
			num, err := strconv.Atoi(opt[0])
			if err != nil {
				logger.Warn("Invalid option: %s", opt[0])
				continue
			}
			if num > 0 && num <= len(options) {
				logger.Info("%v", options[num-1])
				args = append(args, urls[num-1])
			} else {
				logger.Warn("Option out of range: %s", opt[0])
			}
		} else if len(opt) == 2 {
			start, err1 := strconv.Atoi(opt[0])
			end, err2 := strconv.Atoi(opt[1])
			if err1 != nil || err2 != nil {
				logger.Warn("Invalid range: %v", opt)
				continue
			}
			if start < 1 || end > len(options) || start > end {
				logger.Warn("Range out of range: %v", opt)
				continue
			}
			for i := start; i <= end; i++ {
				logger.Info("%v", options[i-1])
				args = append(args, urls[i-1])
			}
		} else {
			logger.Warn("Invalid option: %v", opt)
		}
	}
	return args, nil
}

// GetMeta retrieves metadata for an album or playlist
func GetMeta(albumId string, account *structs.Account, storefront string) (*structs.AutoGenerated, error) {
	var mtype string
	var next string
	if strings.Contains(albumId, "pl.") {
		mtype = "playlists"
	} else {
		mtype = "albums"
	}
	req, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/%s/%s", storefront, mtype, albumId), nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	req.Header.Set("Origin", "https://music.apple.com")
	query := url.Values{}
	query.Set("omit[resource]", "autos")
	query.Set("include", "tracks,artists,record-labels")
	query.Set("include[songs]", "artists,albums")
	query.Set("fields[artists]", "name,artwork")
	query.Set("fields[albums:albums]", "artistName,artwork,name,releaseDate,url")
	query.Set("fields[record-labels]", "name")
	query.Set("extend", "editorialVideo")
	query.Set("l", core.Config.Language)
	req.URL.RawQuery = query.Encode()
	do, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("è·å–å…ƒæ•°æ®è¯·æ±‚å¤±è´¥: %w", err)
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		logger.Debug("[API] GetMeta å¤±è´¥: HTTP %s, albumId=%s", do.Status, albumId)
		return nil, fmt.Errorf("è·å–ä¸“è¾‘å…ƒæ•°æ®å¤±è´¥ (HTTP %s): ID=%s", do.Status, albumId)
	}
	obj := new(structs.AutoGenerated)
	err = json.NewDecoder(do.Body).Decode(&obj)
	if err != nil {
		return nil, fmt.Errorf("è§£æä¸“è¾‘å…ƒæ•°æ®å¤±è´¥: %w", err)
	}
	if strings.Contains(albumId, "pl.") {
		obj.Data[0].Attributes.ArtistName = "Apple Music"
	}
	if len(obj.Data[0].Relationships.Tracks.Next) > 0 {
		next = obj.Data[0].Relationships.Tracks.Next
		for {
			req, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/%s&l=%s&include=albums", next, core.Config.Language), nil)
			if err != nil {
				return nil, err
			}
			req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
			req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
			req.Header.Set("Origin", "https://music.apple.com")
			do, err := http.DefaultClient.Do(req)
			if err != nil {
				return nil, err
			}

			// ä½¿ç”¨é—­åŒ…ç«‹å³å…³é—­ HTTP è¿æ¥ï¼Œé¿å…åœ¨å¾ªç¯ä¸­ç´¯ç§¯
			var hasNext bool
			err = func() error {
				defer do.Body.Close()

				if do.StatusCode != http.StatusOK {
					logger.Debug("[API] GetMeta è·å–æ›´å¤šæ›²ç›®å¤±è´¥: HTTP %s", do.Status)
					return fmt.Errorf("è·å–æ›´å¤šæ›²ç›®å¤±è´¥ (HTTP %s)", do.Status)
				}
				obj2 := new(structs.AutoGeneratedTrack)
				if err := json.NewDecoder(do.Body).Decode(&obj2); err != nil {
					return fmt.Errorf("è§£ææ›²ç›®æ•°æ®å¤±è´¥: %w", err)
				}

				for _, value := range obj2.Data {
					obj.Data[0].Relationships.Tracks.Data = append(obj.Data[0].Relationships.Tracks.Data, value)
				}
				next = obj2.Next
				hasNext = len(next) > 0

				return nil
			}()

			if err != nil {
				return nil, err
			}

			if !hasNext {
				break
			}
		}
	}
	return obj, nil
}

// GetInfoFromAdam retrieves song data from the API
func GetInfoFromAdam(trackid string, account *structs.Account, storefront string) (*structs.SongData, error) {
	request, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/songs/%s", storefront, trackid), nil)
	if err != nil {
		return nil, err
	}
	query := url.Values{}
	query.Set("extend", "extendedAssetUrls")
	query.Set("include", "albums")
	query.Set("l", core.Config.Language)
	request.URL.RawQuery = query.Encode()

	request.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
	request.Header.Set("User-Agent", "iTunes/12.11.3 (Windows; Microsoft Windows 10 x64 Professional Edition (Build 19041); x64) AppleWebKit/7611.1022.4001.1 (dt:2)")
	request.Header.Set("Origin", "https://music.apple.com")

	do, err := http.DefaultClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("è¯·æ±‚æ›²ç›®ä¿¡æ¯å¤±è´¥: %w", err)
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		logger.Debug("[API] GetInfoFromAdam å¤±è´¥: HTTP %s, trackId=%s", do.Status, trackid)
		return nil, fmt.Errorf("è·å–æ›²ç›®ä¿¡æ¯å¤±è´¥ (HTTP %s): ID=%s", do.Status, trackid)
	}

	obj := new(structs.ApiResult)
	err = json.NewDecoder(do.Body).Decode(&obj)
	if err != nil {
		return nil, fmt.Errorf("è§£ææ›²ç›®ä¿¡æ¯å¤±è´¥: %w", err)
	}

	for _, d := range obj.Data {
		if d.ID == trackid {
			return &d, nil
		}
	}
	return nil, nil
}

// GetMVInfoFromAdam retrieves music video data from the API
func GetMVInfoFromAdam(mvId string, account *structs.Account, storefront string) (*structs.AutoGeneratedMusicVideo, error) {
	request, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/music-videos/%s", storefront, mvId), nil)
	if err != nil {
		return nil, err
	}
	query := url.Values{}
	query.Set("l", core.Config.Language)
	request.URL.RawQuery = query.Encode()
	request.Header.Set("Authorization", fmt.Sprintf("Bearer %s", core.DeveloperToken))
	request.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	request.Header.Set("Origin", "https://music.apple.com")

	do, err := http.DefaultClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("è¯·æ±‚ MV ä¿¡æ¯å¤±è´¥: %w", err)
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		logger.Debug("[API] GetMVInfoFromAdam å¤±è´¥: HTTP %s, mvId=%s", do.Status, mvId)
		return nil, fmt.Errorf("è·å– MV ä¿¡æ¯å¤±è´¥ (HTTP %s): ID=%s", do.Status, mvId)
	}

	obj := new(structs.AutoGeneratedMusicVideo)
	err = json.NewDecoder(do.Body).Decode(&obj)
	if err != nil {
		return nil, fmt.Errorf("è§£æ MV ä¿¡æ¯å¤±è´¥: %w", err)
	}

	return obj, nil
}

// GetToken retrieves the developer token from Apple's website
func GetToken() (string, error) {
	req, err := http.NewRequest("GET", "https://beta.music.apple.com", nil)
	if err != nil {
		return "", err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	// å°è¯•å¤šç§å¯èƒ½çš„ JS æ–‡ä»¶å‘½åæ¨¡å¼
	patterns := []string{
		`/assets/index~[^"]+\.js`,        // æ–°ç‰ˆæœ¬æ ¼å¼
		`/assets/index-legacy-[^/]+\.js`, // æ—§ç‰ˆæœ¬æ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰
		`/assets/index[^"]*\.js`,         // é€šç”¨æ ¼å¼
	}

	var indexJsUri string
	for _, pattern := range patterns {
		regex := regexp.MustCompile(pattern)
		indexJsUri = regex.FindString(string(body))
		if indexJsUri != "" {
			logger.Debug("[Token] æ‰¾åˆ° JS æ–‡ä»¶: %s", indexJsUri)
			break
		}
	}

	if indexJsUri == "" {
		preview := string(body)
		if len(preview) > 200 {
			preview = preview[:200]
		}
		logger.Debug("[Token] ç½‘é¡µå†…å®¹é¢„è§ˆ: %s...", preview)
		return "", fmt.Errorf("æ— æ³•åœ¨ HTML ä¸­æ‰¾åˆ° JS èµ„æºæ–‡ä»¶ï¼ˆå°è¯•äº† %d ç§æ¨¡å¼ï¼‰", len(patterns))
	}
	req, err = http.NewRequest("GET", "https://beta.music.apple.com"+indexJsUri, nil)
	if err != nil {
		return "", err
	}
	resp, err = http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, err = io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("è¯»å– JS æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// JWT token é€šå¸¸ä»¥ eyJ å¼€å¤´ï¼ˆBase64 ç¼–ç çš„ {"alg"...ï¼‰
	regex := regexp.MustCompile(`eyJh[A-Za-z0-9\-_\.]+`)
	token := regex.FindString(string(body))
	if token == "" {
		logger.Debug("[Token] æ— æ³•åœ¨ JS æ–‡ä»¶ä¸­æ‰¾åˆ° token")
		logger.Debug("[Token] JS æ–‡ä»¶å¤§å°: %d bytes", len(body))
		return "", fmt.Errorf("æ— æ³•åœ¨ JS æ–‡ä»¶ä¸­æ‰¾åˆ°å¼€å‘è€… token")
	}

	logger.Debug("[Token] æˆåŠŸè·å–åˆ° token (é•¿åº¦: %d)", len(token))
	return token, nil
}
