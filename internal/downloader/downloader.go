package downloader

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"main/internal/api"
	"main/internal/core"
	"main/internal/logger"
	"main/internal/metadata"
	"main/internal/parser"
	"main/internal/progress"
	"main/internal/ui"
	"main/internal/utils"
	"main/utils/lyrics"
	"main/utils/runv14"
	"main/utils/runv3"
	"main/utils/structs"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
)

// cleanupEmptyAlbumFolders æ¸…ç†åªåŒ…å« cover.jpg çš„ç©ºæ–‡ä»¶å¤¹
// è¿™äº›æ–‡ä»¶å¤¹æ˜¯ç”±äºéŸ³è´¨æ ‡ç­¾ä¸ä¸€è‡´è€Œäº§ç”Ÿçš„å†—ä½™æ–‡ä»¶å¤¹
func cleanupEmptyAlbumFolders(baseSaveFolder string) int {
	cleanedCount := 0
	filepath.Walk(baseSaveFolder, func(path string, info os.FileInfo, err error) error {
		if err != nil || !info.IsDir() || path == baseSaveFolder {
			return nil
		}

		files, err := os.ReadDir(path)
		if err != nil {
			return nil
		}

		// æ£€æŸ¥æ˜¯å¦åªåŒ…å« cover.jpg æˆ– folder.jpg
		if len(files) == 0 {
			// ç©ºæ–‡ä»¶å¤¹ï¼Œåˆ é™¤
			os.RemoveAll(path)
			cleanedCount++
		} else if len(files) == 1 {
			fileName := files[0].Name()
			if fileName == "cover.jpg" || fileName == "folder.jpg" {
				// åªæœ‰å°é¢å›¾ç‰‡ï¼Œåˆ é™¤æ•´ä¸ªæ–‡ä»¶å¤¹
				os.RemoveAll(path)
				cleanedCount++
			}
		} else if len(files) == 2 {
			// æ£€æŸ¥æ˜¯å¦åªæœ‰ cover.jpg å’Œ folder.jpg
			hasCover := false
			hasFolder := false
			for _, f := range files {
				if f.Name() == "cover.jpg" {
					hasCover = true
				} else if f.Name() == "folder.jpg" {
					hasFolder = true
				} else {
					// æœ‰å…¶ä»–æ–‡ä»¶ï¼Œä¸æ˜¯ç©ºæ–‡ä»¶å¤¹
					return nil
				}
			}
			if hasCover && hasFolder {
				// åªæœ‰ä¸¤ä¸ªå°é¢å›¾ç‰‡ï¼Œåˆ é™¤
				os.RemoveAll(path)
				cleanedCount++
			}
		}
		return nil
	})
	return cleanedCount
}

// GetCacheBasePath æ ¹æ®æ˜¯å¦å¯ç”¨ç¼“å­˜è¿”å›åŸºç¡€è·¯å¾„
// è¿”å›å€¼: (å®é™…ä½¿ç”¨çš„è·¯å¾„, æœ€ç»ˆç›®æ ‡è·¯å¾„, æ˜¯å¦ä½¿ç”¨ç¼“å­˜)
func GetCacheBasePath(targetPath, albumId string) (string, string, bool) {
	if !core.Config.EnableCache {
		return targetPath, targetPath, false
	}

	// åˆ›å»ºå”¯ä¸€çš„ç¼“å­˜å­ç›®å½•ï¼ˆä½¿ç”¨albumIdçš„hashé¿å…å†²çªï¼‰
	hash := sha256.Sum256([]byte(albumId + targetPath))
	cacheSubDir := hex.EncodeToString(hash[:])[:16]
	cachePath := filepath.Join(core.Config.CacheFolder, cacheSubDir)

	// ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
	if err := os.MkdirAll(cachePath, 0755); err != nil {
		// å¦‚æœåˆ›å»ºç¼“å­˜ç›®å½•å¤±è´¥ï¼Œè¿”å›ç›´æ¥ä¿å­˜æ¨¡å¼
		return "", targetPath, false
	}

	return cachePath, targetPath, true
}

// SafeMoveFile å¯¼å‡ºutilsåŒ…ä¸­çš„SafeMoveFileå‡½æ•°ï¼Œæ–¹ä¾¿å¤–éƒ¨è°ƒç”¨
func SafeMoveFile(src, dst string) error {
	return utils.SafeMoveFile(src, dst)
}

func checkAndReEncodeTrack(trackPath string, statusIndex int, notifier *progress.ProgressNotifier) (bool, error) {
	if notifier != nil {
		notifier.NotifyStatus(statusIndex, "æ­£åœ¨æ£€æµ‹...", "check")
	}
	checkArgs := strings.Fields(core.Config.FfmpegCheckArgs)
	cmdCheckArgs := append([]string{"-i", trackPath}, checkArgs...)
	checkCmd := exec.Command("ffmpeg", cmdCheckArgs...)

	var stderr bytes.Buffer
	checkCmd.Stderr = &stderr
	err := checkCmd.Run()

	if err == nil && stderr.Len() == 0 {
		return false, nil
	}

	if notifier != nil {
		notifier.NotifyStatus(statusIndex, "æ–‡ä»¶æŸå, æ­£åœ¨é‡æ–°ç¼–ç ...", "reencode")
	}

	tempTrackPath := trackPath + ".fixed.m4a"
	defer os.Remove(tempTrackPath)

	encodeArgs := strings.Fields(core.Config.FfmpegEncodeArgs)
	cmdEncodeArgs := append([]string{"-i", trackPath}, encodeArgs...)
	cmdEncodeArgs = append(cmdEncodeArgs, tempTrackPath)

	encodeCmd := exec.Command("ffmpeg", cmdEncodeArgs...)
	var encodeStderr bytes.Buffer
	encodeCmd.Stderr = &encodeStderr
	err = encodeCmd.Run()

	if err != nil {
		return true, fmt.Errorf("é‡æ–°ç¼–ç å¤±è´¥: %v, FFMPEGè¾“å‡º: %s", err, encodeStderr.String())
	}

	if err := os.Remove(trackPath); err != nil {
		return true, fmt.Errorf("åˆ é™¤æŸåçš„åŸæ–‡ä»¶å¤±è´¥: %w", err)
	}
	if err := os.Rename(tempTrackPath, trackPath); err != nil {
		return true, fmt.Errorf("æ›¿æ¢ä¸ºä¿®å¤æ–‡ä»¶å¤±è´¥: %w", err)
	}

	return true, nil
}

func downloadTrackWithFallback(track structs.TrackData, meta *structs.AutoGenerated, albumId, storefront, baseSaveFolder, finalSaveFolder, Codec, covPath string, workingAccounts []structs.Account, initialAccountIndex int, statusIndex int, updateStatus func(index int, status string, sColor func(a ...interface{}) string), progressChan chan runv14.ProgressUpdate) (string, error) {
	maxRetries := 3 // æ¯ä¸ªè´¦å·æœ€å¤šé‡è¯•æ¬¡æ•°
	var lastError error
	yellow := color.New(color.FgYellow).SprintFunc()
	red := color.New(color.FgRed).SprintFunc()

	// è¿æ¥å¤±è´¥è®¡æ•°å™¨ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦è·³è¿‡ï¼‰
	connectionRefusedCount := 0
	const maxConnectionRefusedRetries = 3

	for i := 0; i < len(workingAccounts); i++ {
		accountIndex := (initialAccountIndex + i) % len(workingAccounts)
		account := &workingAccounts[accountIndex]

		for attempt := 0; attempt <= maxRetries; attempt++ {
			trackPath, err := downloadTrackSilently(track, meta, albumId, storefront, baseSaveFolder, finalSaveFolder, Codec, covPath, account, progressChan)
			if err == nil {
				return trackPath, nil
			}
			lastError = err

			// æ£€æµ‹è¿æ¥è¢«æ‹’ç»é”™è¯¯
			if strings.Contains(err.Error(), "connection refused") {
				connectionRefusedCount++
				// åŸåœ°åˆ·æ–°æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
				updateStatus(statusIndex, fmt.Sprintf("è¿æ¥å¤±è´¥ %d/%d: æ­£åœ¨é‡è¯•...", connectionRefusedCount, maxConnectionRefusedRetries), yellow)

				// è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç›´æ¥è·³è¿‡
				if connectionRefusedCount >= maxConnectionRefusedRetries {
					updateStatus(statusIndex, "è¿æ¥æœåŠ¡å¤±è´¥ï¼Œå·²è·³è¿‡", red)
					return "", fmt.Errorf("è¿æ¥æœåŠ¡æŒç»­å¤±è´¥ï¼Œå·²è·³è¿‡æ­¤æ›²ç›®")
				}
			} else {
				// éè¿æ¥é”™è¯¯ï¼Œæ˜¾ç¤ºç®€çŸ­æç¤º
				errorMsg := err.Error()
				if len(errorMsg) > 40 {
					errorMsg = errorMsg[:37] + "..."
				}
				updateStatus(statusIndex, fmt.Sprintf("é‡è¯• %d/%d: %s", attempt+1, maxRetries+1, errorMsg), yellow)
			}

			if attempt < maxRetries {
				time.Sleep(1500 * time.Millisecond)
			}
		}

		// å•ä¸ªè´¦æˆ·å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªï¼ˆåŸåœ°åˆ·æ–°ï¼‰
		if i < len(workingAccounts)-1 {
			updateStatus(statusIndex, fmt.Sprintf("è´¦æˆ· %s å¤±è´¥ï¼Œåˆ‡æ¢ä¸­...", account.Name), yellow)
			time.Sleep(500 * time.Millisecond)
		}
	}

	// æˆªæ–­æœ€ç»ˆé”™è¯¯ä¿¡æ¯ï¼Œé¿å…è¿‡é•¿
	errorMsg := lastError.Error()
	if len(errorMsg) > 50 {
		errorMsg = errorMsg[:47] + "..."
	}
	return "", fmt.Errorf("æ‰€æœ‰è´¦æˆ·å¤±è´¥: %s", errorMsg)
}

func downloadTrackSilently(track structs.TrackData, meta *structs.AutoGenerated, albumId, storefront, baseSaveFolder, finalSaveFolder, Codec, covPath string, account *structs.Account, progressChan chan runv14.ProgressUpdate) (string, error) {
	if track.Type == "music-videos" {
		// ä¸“è¾‘ä¸­çš„MVï¼šä¸‹è½½åˆ°ä¸“è¾‘ç›®å½•ï¼Œä½¿ç”¨ç®€åŒ–å‘½åï¼ˆå’Œæ­Œæ›²ä¸€æ ·çš„å‘½åè§„åˆ™ï¼‰
		if !core.Config.DownloadVideos {
			core.OkDict[albumId] = append(core.OkDict[albumId], -1)
			return "", nil
		}

		if len(account.MediaUserToken) <= 50 {
			return "", errors.New("media-user-token is not set, skip MV dl")
		}
		if _, err := exec.LookPath("mp4decrypt"); err != nil {
			return "", errors.New("mp4decrypt is not found, skip MV dl")
		}

		// è®¡ç®—MVåœ¨ä¸“è¾‘ä¸­çš„ä½ç½®
		trackNum := -1
		for i, t := range meta.Data[0].Relationships.Tracks.Data {
			if t.ID == track.ID {
				trackNum = i + 1
				break
			}
		}
		if trackNum == -1 {
			return "", errors.New("track not found in metadata")
		}

		// ä½¿ç”¨å’Œæ­Œæ›²ç›¸åŒçš„æ–‡ä»¶å¤¹ç»“æ„
		var singerFoldername, albumFoldername string
		if core.Config.ArtistFolderFormat != "" {
			if strings.Contains(albumId, "pl.") {
				singerFoldername = strings.NewReplacer(
					"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
				).Replace(core.Config.ArtistFolderFormat)
			} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
				singerFoldername = strings.NewReplacer(
					"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
				).Replace(core.Config.ArtistFolderFormat)
			} else {
				singerFoldername = strings.NewReplacer(
					"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{ArtistId}", "",
				).Replace(core.Config.ArtistFolderFormat)
			}
		}

		// MVä½¿ç”¨Videoæ ‡ç­¾
		Quality := "Video"
		MVCodec := "H.264"
		Tag_string := ""

		if strings.Contains(albumId, "pl.") {
			albumFoldername = strings.NewReplacer(
				"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
				"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", MVCodec, "{Tag}", Tag_string,
			).Replace(core.Config.PlaylistFolderFormat)
		} else {
			albumFoldername = strings.NewReplacer(
				"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
				"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
				"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
				"{Quality}", Quality, "{Codec}", MVCodec, "{Tag}", Tag_string,
			).Replace(core.Config.AlbumFolderFormat)
		}

		// MVæ–‡ä»¶åä½¿ç”¨å’Œæ­Œæ›²ç›¸åŒçš„å‘½åè§„åˆ™ï¼Œä½†åç¼€ä¸º.mp4
		mvFileName := strings.NewReplacer(
			"{SongId}", track.ID,
			"{SongNumer}", fmt.Sprintf("%02d", trackNum),
			"{SongName}", core.LimitString(track.Attributes.Name),
			"{DiscNumber}", fmt.Sprintf("%0d", track.Attributes.DiscNumber),
			"{TrackNumber}", fmt.Sprintf("%0d", track.Attributes.TrackNumber),
			"{Quality}", Quality,
			"{Tag}", Tag_string,
			"{Codec}", MVCodec,
		).Replace(core.Config.SongFileFormat)

		sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
		sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")
		sanitizedMvName := core.ForbiddenNames.ReplaceAllString(mvFileName, "_")
		filenameWithExt := fmt.Sprintf("%s.mp4", sanitizedMvName)

		finalArtistDir, finalAlbumDir, finalFilename := utils.EnsureSafePath(baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, filenameWithExt)
		var finalSingerFolder string
		if finalArtistDir != "" {
			finalSingerFolder = filepath.Join(baseSaveFolder, finalArtistDir)
		} else {
			finalSingerFolder = baseSaveFolder
		}
		finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
		if err := os.MkdirAll(finalAlbumFolder, 0755); err != nil {
			return "", fmt.Errorf("åˆ›å»ºä¸“è¾‘ç›®å½•å¤±è´¥: %w", err)
		}
		mvPath := filepath.Join(finalAlbumFolder, finalFilename)

		// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
		checkPath := mvPath
		returnPath := mvPath
		if finalSaveFolder != baseSaveFolder {
			// ä½¿ç”¨ç¼“å­˜æ—¶ï¼Œæ£€æŸ¥æœ€ç»ˆç›®æ ‡è·¯å¾„æ˜¯å¦å·²å­˜åœ¨æ–‡ä»¶
			var targetSingerFolder string
			if finalArtistDir != "" {
				targetSingerFolder = filepath.Join(finalSaveFolder, finalArtistDir)
			} else {
				targetSingerFolder = finalSaveFolder
			}
			targetAlbumFolder := filepath.Join(targetSingerFolder, finalAlbumDir)
			checkPath = filepath.Join(targetAlbumFolder, finalFilename)
			returnPath = checkPath
		}

		// å¼ºåˆ¶ä¸‹è½½æ¨¡å¼è·³è¿‡æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
		if !core.ForceDownload {
			exists, err := utils.FileExists(checkPath)
			if err != nil {
				return "", errors.New("failed to check if MV exists")
			}
			if exists {
				core.SharedLock.Lock()
				core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
				core.SharedLock.Unlock()
				return returnPath, nil
			}
		}

		// ä¸‹è½½MVï¼ˆå¸¦åŠ å›ºçš„é”™è¯¯å¤„ç†å’Œèµ„æºæ¸…ç†ï¼‰
		vidPath := filepath.Join(finalAlbumFolder, fmt.Sprintf("%s_vid.mp4", track.ID))
		audPath := filepath.Join(finalAlbumFolder, fmt.Sprintf("%s_aud.mp4", track.ID))

		// ç¡®ä¿å³ä½¿å‘ç”Ÿé”™è¯¯ä¹Ÿæ¸…ç†ä¸´æ—¶æ–‡ä»¶
		defer func() {
			if _, err := os.Stat(vidPath); err == nil {
				os.Remove(vidPath)
			}
			if _, err := os.Stat(audPath); err == nil {
				os.Remove(audPath)
			}
		}()

		mvm3u8url, _, err := runv3.GetWebplayback(track.ID, core.DeveloperToken, account.MediaUserToken, true)
		if err != nil {
			return "", fmt.Errorf("è·å–MVæ’­æ”¾åˆ—è¡¨å¤±è´¥: %w", err)
		}
		if mvm3u8url == "" {
			return "", errors.New("media-user-token may be wrong or expired")
		}

		videom3u8url, _, err := parser.ExtractVideo(mvm3u8url)
		if err != nil {
			return "", fmt.Errorf("æå–è§†é¢‘æµURLå¤±è´¥: %w", err)
		}

		videokeyAndUrls, err := runv3.Run(track.ID, videom3u8url, core.DeveloperToken, account.MediaUserToken, true)
		if err != nil {
			return "", fmt.Errorf("è·å–è§†é¢‘å¯†é’¥å’ŒURLå¤±è´¥: %w", err)
		}
		err = runv3.ExtMvData(videokeyAndUrls, vidPath)
		if err != nil {
			return "", fmt.Errorf("ä¸‹è½½æˆ–è§£å¯†è§†é¢‘æ•°æ®å¤±è´¥: %w", err)
		}

		// éªŒè¯è§†é¢‘æ–‡ä»¶å¤§å°ï¼ˆé˜²æ­¢ä¸‹è½½ä¸å®Œæ•´ï¼‰
		if vidInfo, err := os.Stat(vidPath); err == nil {
			if vidInfo.Size() < 1024*100 { // å°äº100KBè§†ä¸ºå¼‚å¸¸
				return "", fmt.Errorf("è§†é¢‘æ–‡ä»¶è¿‡å° (%d bytes)ï¼Œå¯èƒ½ä¸‹è½½ä¸å®Œæ•´", vidInfo.Size())
			}
		}

		audiom3u8url, err := parser.ExtractMvAudio(mvm3u8url)
		if err != nil {
			return "", fmt.Errorf("æå–éŸ³é¢‘æµURLå¤±è´¥: %w", err)
		}
		audiokeyAndUrls, err := runv3.Run(track.ID, audiom3u8url, core.DeveloperToken, account.MediaUserToken, true)
		if err != nil {
			return "", fmt.Errorf("è·å–éŸ³é¢‘å¯†é’¥å’ŒURLå¤±è´¥: %w", err)
		}
		err = runv3.ExtMvData(audiokeyAndUrls, audPath)
		if err != nil {
			return "", fmt.Errorf("ä¸‹è½½æˆ–è§£å¯†éŸ³é¢‘æ•°æ®å¤±è´¥: %w", err)
		}

		// éªŒè¯éŸ³é¢‘æ–‡ä»¶å¤§å°
		if audInfo, err := os.Stat(audPath); err == nil {
			if audInfo.Size() < 1024*10 { // å°äº10KBè§†ä¸ºå¼‚å¸¸
				return "", fmt.Errorf("éŸ³é¢‘æ–‡ä»¶è¿‡å° (%d bytes)ï¼Œå¯èƒ½ä¸‹è½½ä¸å®Œæ•´", audInfo.Size())
			}
		}

		// åˆå¹¶è§†é¢‘å’ŒéŸ³é¢‘
		muxCmd := exec.Command("MP4Box", "-quiet", "-add", vidPath, "-add", audPath, "-keep-utc", "-new", mvPath)
		if err := muxCmd.Run(); err != nil {
			return "", fmt.Errorf("åˆå¹¶è§†é¢‘éŸ³é¢‘å¤±è´¥: %w", err)
		}

		// éªŒè¯æœ€ç»ˆæ–‡ä»¶å¤§å°
		if mvInfo, err := os.Stat(mvPath); err == nil {
			if mvInfo.Size() < 1024*1024 { // å°äº1MBè§†ä¸ºå¼‚å¸¸
				os.Remove(mvPath) // åˆ é™¤å¼‚å¸¸æ–‡ä»¶
				return "", fmt.Errorf("åˆå¹¶åçš„MVæ–‡ä»¶è¿‡å° (%d bytes)ï¼Œå·²åˆ é™¤", mvInfo.Size())
			}
		}

		core.SharedLock.Lock()
		core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
		core.SharedLock.Unlock()

		return mvPath, nil
	}

	manifest, err := api.GetInfoFromAdam(track.ID, account, storefront)
	if err != nil {
		return "", fmt.Errorf("failed to get manifest with account %s: %w", account.Name, err)
	}

	if manifest.Attributes.ExtendedAssetUrls.EnhancedHls == "" {
		if core.Dl_atmos {
			return "", errors.New("atmos unavailable")
		}
		// For AAC modes that need specific stream selection, we need to check M3U8
		if core.Dl_aac && (*core.Aac_type == "aac-binaural" || *core.Aac_type == "aac-downmix") {
			// These AAC types require stream selection, need to check M3U8
		} else if core.Dl_aac && *core.Aac_type == "aac-lc" {
			// AAC-LC also needs token for decryption
		}
	}
	needCheck := false

	if core.Config.GetM3u8Mode == "all" {
		needCheck = true
	} else if core.Config.GetM3u8Mode == "hires" && utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
		needCheck = true
	}
	var EnhancedHls_m3u8 string
	if needCheck && !core.Dl_aac {
		EnhancedHls_m3u8, _ = parser.CheckM3u8(track.ID, "song", account)
		if strings.HasSuffix(EnhancedHls_m3u8, ".m3u8") {
			manifest.Attributes.ExtendedAssetUrls.EnhancedHls = EnhancedHls_m3u8
		}
	}
	var Quality string
	if strings.Contains(core.Config.SongFileFormat, "Quality") {
		if core.Dl_atmos {
			Quality = fmt.Sprintf("%dkbps", *core.Atmos_max-2000)
		} else if core.Dl_aac && *core.Aac_type == "aac-lc" {
			Quality = "256kbps"
		} else if core.Dl_aac {
			// For other AAC types, try to extract quality from M3U8
			if manifest.Attributes.ExtendedAssetUrls.EnhancedHls != "" {
				_, Quality, _, err = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, true)
				if err != nil {
					Quality = ""
				}
			} else {
				Quality = "AAC"
			}
		} else {
			_, Quality, _, err = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, true)
			if err != nil {
				Quality = ""
			}
		}
	}
	// Determine quality tag: RESPECT USER CHOICE FIRST, then fallback to auto-detection
	// {Tag} variable is specifically for audio quality
	var Tag_string string

	// Priority 1: Respect user's explicit quality choice
	if core.Dl_atmos {
		Tag_string = utils.FormatQualityTag("Dolby Atmos")
	} else if core.Dl_aac && *core.Aac_type == "aac-binaural" {
		Tag_string = utils.FormatQualityTag("Aac Binaural")
	} else if core.Dl_aac && *core.Aac_type == "aac-downmix" {
		Tag_string = utils.FormatQualityTag("Aac Downmix")
	} else if core.Dl_aac && *core.Aac_type == "aac-lc" {
		Tag_string = utils.FormatQualityTag("Aac 256")
	} else if core.Dl_aac {
		// Generic AAC mode - check if user wants specific type
		if *core.Aac_type != "aac" {
			Tag_string = utils.FormatQualityTag("Aac " + strings.Title(*core.Aac_type))
		} else {
			Tag_string = utils.FormatQualityTag("Aac 256")
		}
	} else {
		// Priority 2: Auto-detect best quality when user didn't specify
		if utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
			Tag_string = utils.FormatQualityTag("Hi-Res Lossless")
		} else if utils.Contains(track.Attributes.AudioTraits, "lossless") {
			Tag_string = utils.FormatQualityTag("Alac")
		} else if utils.Contains(track.Attributes.AudioTraits, "atmos") {
			Tag_string = utils.FormatQualityTag("Dolby Atmos")
		} else {
			Tag_string = utils.FormatQualityTag("Aac 256")
		}
	}

	trackNum := -1
	for i, t := range meta.Data[0].Relationships.Tracks.Data {
		if t.ID == track.ID {
			trackNum = i + 1
			break
		}
	}
	if trackNum == -1 {
		return "", errors.New("track not found in metadata")
	}

	var singerFoldername, albumFoldername string
	if core.Config.ArtistFolderFormat != "" {
		if strings.Contains(albumId, "pl.") {
			singerFoldername = strings.NewReplacer(
				"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
			).Replace(core.Config.ArtistFolderFormat)
		} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
			).Replace(core.Config.ArtistFolderFormat)
		} else {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", "",
			).Replace(core.Config.ArtistFolderFormat)
		}
	}

	// æ£€æŸ¥æ˜¯å¦ä¸ºè™šæ‹ŸSinglesä¸“è¾‘
	isSingle := core.IsSingleAlbum(meta)

	// å¯¹äºè™šæ‹ŸSinglesä¸“è¾‘ï¼Œæå‰è®¡ç®—æœ‰æ•ˆçš„æ›²ç›®ç¼–å·ï¼ˆåœ¨æ•´ä¸ªå‡½æ•°ä¸­å¤ç”¨ï¼Œé¿å…é‡å¤è°ƒç”¨ï¼‰
	effectiveTrackNum := trackNum
	var primaryArtist string
	if isSingle {
		// å•æ›²ä¸“è¾‘ï¼šå§‹ç»ˆä½¿ç”¨ä¸»è¦è‰ºæœ¯å®¶ï¼ˆä»ä¸“è¾‘è‰ºæœ¯å®¶åä¸­æå–ç¬¬ä¸€ä¸ªï¼‰
		// è¿™æ · "Alec Benjamin [feat. é™ˆå©§éœ]" ä¼šè¢«å½’ç±»åˆ° "Alec Benjamin - Singles"
		// "é™ˆå©§éœ" ä¼šè¢«å½’ç±»åˆ° "é™ˆå©§éœ - Singles"
		primaryArtist = core.GetPrimaryArtist(meta.Data[0].Attributes.ArtistName)
		logger.Debug("[è™šæ‹ŸSingles] ä¸“è¾‘: '%s', ä¸“è¾‘è‰ºæœ¯å®¶: '%s', ä¸»è¦è‰ºæœ¯å®¶: '%s'",
			meta.Data[0].Attributes.Name,
			meta.Data[0].Attributes.ArtistName,
			primaryArtist)

		effectiveTrackNum = core.GetVirtualSinglesTrackNumber(primaryArtist)
		// ä¿å­˜æœ‰æ•ˆæ›²ç›®ç¼–å·ï¼Œä¾›åç»­WriteMP4Tagsä½¿ç”¨ï¼ˆç¡®ä¿æ–‡ä»¶åå’Œæ ‡ç­¾ç¼–å·ä¸€è‡´ï¼‰
		core.SetTrackEffectiveNumber(track.ID, effectiveTrackNum)

		// å¯¹äºè™šæ‹ŸSinglesä¸“è¾‘ï¼Œè‰ºæœ¯å®¶æ–‡ä»¶å¤¹ä¹Ÿåº”ä½¿ç”¨ä¸»è¦è‰ºæœ¯å®¶
		// è¦†ç›–ä¹‹å‰è®¾ç½®çš„ singerFoldernameï¼ˆé¿å…ä½¿ç”¨å®Œæ•´çš„åˆä½œè‰ºæœ¯å®¶åï¼‰
		if core.Config.ArtistFolderFormat != "" {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(primaryArtist),
				"{ArtistName}", core.LimitString(primaryArtist),
				"{ArtistId}", "", // Singles ä¸“è¾‘ä¸éœ€è¦è‰ºæœ¯å®¶ID
			).Replace(core.Config.ArtistFolderFormat)
		}
	}

	if strings.Contains(albumId, "pl.") {
		albumFoldername = strings.NewReplacer(
			"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.PlaylistFolderFormat)
	} else if isSingle {
		// è™šæ‹ŸSinglesä¸“è¾‘ï¼šä½¿ç”¨ä¸»è¦è‰ºæœ¯å®¶åï¼ˆå¤„ç†åˆä½œè€…æƒ…å†µï¼‰
		singlesFolder := core.Config.VirtualSinglesFolderName
		if singlesFolder == "" {
			singlesFolder = "Singles"
		}
		// æ ¼å¼: "Olivia Rodrigo - Singles"
		albumFoldername = fmt.Sprintf("%s - %s", core.LimitString(primaryArtist), singlesFolder)
	} else {
		albumFoldername = strings.NewReplacer(
			"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
			"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
			"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
			"{Quality}", Quality, "{Codec}", Codec, "{Tag}", Tag_string,
		).Replace(core.Config.AlbumFolderFormat)
	}

	songName := strings.NewReplacer(
		"{SongId}", track.ID,
		"{SongNumer}", fmt.Sprintf("%02d", effectiveTrackNum),
		"{SongName}", core.LimitString(track.Attributes.Name),
		"{DiscNumber}", fmt.Sprintf("%0d", track.Attributes.DiscNumber),
		"{TrackNumber}", fmt.Sprintf("%0d", track.Attributes.TrackNumber),
		"{Quality}", Quality,
		"{Tag}", Tag_string,
		"{Codec}", Codec,
	).Replace(core.Config.SongFileFormat)

	sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
	sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")
	sanitizedSongName := core.ForbiddenNames.ReplaceAllString(songName, "_")
	filenameWithExt := fmt.Sprintf("%s.m4a", sanitizedSongName)

	finalArtistDir, finalAlbumDir, finalFilename := utils.EnsureSafePath(baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, filenameWithExt)
	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveFolder, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveFolder
	}
	finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
	if err := os.MkdirAll(finalAlbumFolder, 0755); err != nil {
		return "", fmt.Errorf("åˆ›å»ºä¸“è¾‘ç›®å½•å¤±è´¥: %w", err)
	}
	trackPath := filepath.Join(finalAlbumFolder, finalFilename)

	// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼šå¦‚æœä½¿ç”¨ç¼“å­˜ï¼Œæ£€æŸ¥æœ€ç»ˆç›®æ ‡è·¯å¾„ï¼›å¦åˆ™æ£€æŸ¥å½“å‰è·¯å¾„
	checkPath := trackPath
	returnPath := trackPath
	if finalSaveFolder != baseSaveFolder {
		// ä½¿ç”¨ç¼“å­˜æ—¶ï¼Œæ£€æŸ¥æœ€ç»ˆç›®æ ‡è·¯å¾„æ˜¯å¦å·²å­˜åœ¨æ–‡ä»¶
		var targetSingerFolder string
		if finalArtistDir != "" {
			targetSingerFolder = filepath.Join(finalSaveFolder, finalArtistDir)
		} else {
			targetSingerFolder = finalSaveFolder
		}
		targetAlbumFolder := filepath.Join(targetSingerFolder, finalAlbumDir)
		checkPath = filepath.Join(targetAlbumFolder, finalFilename)
		returnPath = checkPath // å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œè¿”å›æœ€ç»ˆç›®æ ‡è·¯å¾„è€Œéç¼“å­˜è·¯å¾„
	}

	// å¼ºåˆ¶ä¸‹è½½æ¨¡å¼è·³è¿‡æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
	if !core.ForceDownload {
		exists, err := utils.FileExists(checkPath)
		if err != nil {
			return "", errors.New("failed to check if track exists")
		}
		if exists {
			logger.Debug("[æ–‡ä»¶è·³è¿‡] æ–‡ä»¶å·²å­˜åœ¨: %s", checkPath)
			core.SharedLock.Lock()
			core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
			core.SharedLock.Unlock()
			// è¿”å›ç‰¹æ®Šæ ‡è®° "EXISTS:" + è·¯å¾„ï¼Œè¡¨ç¤ºæ–‡ä»¶å·²å­˜åœ¨ï¼ˆä¸éœ€è¦è½¬ç§»ï¼‰
			return "EXISTS:" + returnPath, nil
		}
	}

	if core.Dl_aac && *core.Aac_type == "aac-lc" {
		if len(account.MediaUserToken) <= 50 {
			return "", errors.New("invalid media-user-token")
		}
		_, err := runv3.Run(track.ID, trackPath, core.DeveloperToken, account.MediaUserToken, false)
		if err != nil {
			return "", fmt.Errorf("failed to dl aac-lc: %w", err)
		}
	} else {
		trackM3u8Url, _, _, err := parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, false)
		if err != nil {
			return "", fmt.Errorf("failed to extract info from manifest: %w", err)
		}
		err = runv14.Run(track.ID, trackM3u8Url, trackPath, account, core.Config, progressChan)
		if err != nil {
			return "", fmt.Errorf("failed to run v14 with account %s: %w", account.Name, err)
		}
	}

	tags := []string{
		"tool=",
	}
	var trackCovPath string
	if core.Config.EmbedCover {
		// å¯¹äºSinglesè™šæ‹Ÿä¸“è¾‘ï¼Œæ¯ä¸ªå•æ›²å†…åµŒå…¶åŸå§‹å°é¢ï¼ˆåµŒå…¥ååˆ é™¤ä¸´æ—¶æ–‡ä»¶ï¼‰
		if isSingle {
			// ä¸‹è½½å•æ›²çš„åŸå§‹å°é¢ä½œä¸ºä¸´æ—¶æ–‡ä»¶
			trackCovPath, err = metadata.WriteCover(finalAlbumFolder, track.ID, track.Attributes.Artwork.URL)
			if err == nil {
				tags = append(tags, fmt.Sprintf("cover=%s", trackCovPath))
			}
		} else if strings.Contains(albumId, "pl.") && core.Config.DlAlbumcoverForPlaylist {
			_, _, safeCoverFilename := utils.EnsureSafePath(baseSaveFolder, finalArtistDir, finalAlbumDir, track.ID+".jpg")
			trackCovPath, err = metadata.WriteCover(finalAlbumFolder, strings.TrimSuffix(safeCoverFilename, ".jpg"), track.Attributes.Artwork.URL)
			if err == nil {
				tags = append(tags, fmt.Sprintf("cover=%s", trackCovPath))
			}
		} else {
			tags = append(tags, fmt.Sprintf("cover=%s", covPath))
		}
	}
	tagsString := strings.Join(tags, ":")
	cmd := exec.Command("MP4Box", "-quiet", "-itags", tagsString, trackPath)
	_ = cmd.Run()
	// åˆ é™¤ä¸´æ—¶å°é¢æ–‡ä»¶ï¼šæ’­æ”¾åˆ—è¡¨å’ŒSinglesè™šæ‹Ÿä¸“è¾‘éƒ½éœ€è¦åˆ é™¤
	if trackCovPath != "" && (isSingle || (strings.Contains(albumId, "pl.") && core.Config.DlAlbumcoverForPlaylist)) {
		_ = os.Remove(trackCovPath)
	}

	core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
	return trackPath, nil
}

func Rip(albumId string, storefront string, urlArg_i string, urlRaw string, notifier *progress.ProgressNotifier) error {
	mainAccount, err := core.GetAccountForStorefront(storefront)
	if err != nil {
		return err
	}

	var covPath string // å­˜å‚¨ä¸“è¾‘å°é¢è·¯å¾„ï¼Œç”¨äºè™šæ‹ŸSinglesä¸“è¾‘
	var isSingle bool  // æ ‡è¯†æ˜¯å¦ä¸ºè™šæ‹ŸSinglesä¸“è¾‘

	meta, err := api.GetMeta(albumId, mainAccount, storefront)
	if err != nil {
		return err
	}
	var lyricAccount *structs.Account
	for i := range core.Config.Accounts {
		acc := &core.Config.Accounts[i]
		if strings.EqualFold(acc.Storefront, storefront) {
			lyricAccount = acc
			break
		}
	}

	if lyricAccount == nil && core.Config.DefaultLyricStorefront != "" {
		for i := range core.Config.Accounts {
			acc := &core.Config.Accounts[i]
			if strings.EqualFold(acc.Storefront, core.Config.DefaultLyricStorefront) {
				lyricAccount = acc
				break
			}
		}
	}

	if core.Debug_mode {
		if len(meta.Data[0].Relationships.Tracks.Data) > 0 {
			firstTrack := meta.Data[0].Relationships.Tracks.Data[0]
			manifest, err := api.GetInfoFromAdam(firstTrack.ID, mainAccount, storefront)
			if err == nil && manifest.Attributes.ExtendedAssetUrls.EnhancedHls != "" {
				_, _, _, _ = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, true)
			}
		}
		return nil
	}

	var Codec string
	if core.Dl_atmos {
		Codec = "ATMOS"
	} else if core.Dl_aac {
		Codec = "AAC"
	} else {
		Codec = "ALAC"
	}

	var baseSaveFolder string
	var finalSaveFolder string
	var usingCache bool
	if core.Dl_atmos {
		finalSaveFolder = core.Config.AtmosSaveFolder
	} else if core.Dl_aac {
		finalSaveFolder = core.Config.AacSaveFolder
	} else {
		finalSaveFolder = core.Config.AlacSaveFolder
	}

	// ä½¿ç”¨ç¼“å­˜æœºåˆ¶
	baseSaveFolder, finalSaveFolder, usingCache = GetCacheBasePath(finalSaveFolder, albumId)

	// å»¶è¿Ÿæ¸…ç†å‡½æ•°ï¼šå¦‚æœä½¿ç”¨ç¼“å­˜ä¸”å‡ºé”™ï¼Œæ¸…ç†ç¼“å­˜ç›®å½•
	var downloadSuccess bool
	defer func() {
		if usingCache && !downloadSuccess {
			utils.CleanupCacheDirectory(baseSaveFolder)
		}
	}()

	var singerFoldername, albumFoldername string
	if core.Config.ArtistFolderFormat != "" {
		if strings.Contains(albumId, "pl.") {
			singerFoldername = strings.NewReplacer(
				"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
			).Replace(core.Config.ArtistFolderFormat)
		} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
			).Replace(core.Config.ArtistFolderFormat)
		} else {
			singerFoldername = strings.NewReplacer(
				"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
				"{ArtistId}", "",
			).Replace(core.Config.ArtistFolderFormat)
		}
	}

	var Quality string

	// Pre-detect album quality by checking all tracks' audio traits
	// This ensures we use the correct tag from the start, avoiding duplicate folders
	isHires := false
	isLossless := false
	hasAtmos := false
	if !core.Dl_atmos && !core.Dl_aac {
		for _, track := range meta.Data[0].Relationships.Tracks.Data {
			if utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
				isHires = true
				break
			}
			if utils.Contains(track.Attributes.AudioTraits, "lossless") {
				isLossless = true
			}
			if utils.Contains(track.Attributes.AudioTraits, "atmos") {
				hasAtmos = true
			}
		}
	}

	// Determine Album Quality Tag: RESPECT USER CHOICE FIRST, then fallback to auto-detection
	var Album_Tag_string string

	// Priority 1: Respect user's explicit quality choice
	if core.Dl_atmos {
		Album_Tag_string = utils.FormatQualityTag("Dolby Atmos")
	} else if core.Dl_aac && *core.Aac_type == "aac-binaural" {
		Album_Tag_string = utils.FormatQualityTag("Aac Binaural")
	} else if core.Dl_aac && *core.Aac_type == "aac-downmix" {
		Album_Tag_string = utils.FormatQualityTag("Aac Downmix")
	} else if core.Dl_aac && *core.Aac_type == "aac-lc" {
		Album_Tag_string = utils.FormatQualityTag("Aac 256")
	} else if core.Dl_aac {
		// Generic AAC mode - check if user wants specific type
		if *core.Aac_type != "aac" {
			Album_Tag_string = utils.FormatQualityTag("Aac " + strings.Title(*core.Aac_type))
		} else {
			Album_Tag_string = utils.FormatQualityTag("Aac 256")
		}
	} else {
		// Priority 2: Auto-detect best quality when user didn't specify download mode
		if isHires {
			Album_Tag_string = utils.FormatQualityTag("Hi-Res Lossless")
		} else if isLossless {
			Album_Tag_string = utils.FormatQualityTag("Alac")
		} else if hasAtmos {
			Album_Tag_string = utils.FormatQualityTag("Dolby Atmos")
		} else {
			Album_Tag_string = utils.FormatQualityTag("Aac 256")
		}
	}

	// æ£€æŸ¥æ˜¯å¦ä¸ºè™šæ‹ŸSinglesä¸“è¾‘
	isSingle = core.IsSingleAlbum(meta)

	if strings.Contains(albumId, "pl.") {
		albumFoldername = strings.NewReplacer(
			"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{PlaylistId}", albumId, "{Quality}", Quality, "{Codec}", Codec, "{Tag}", Album_Tag_string,
		).Replace(core.Config.PlaylistFolderFormat)
	} else if isSingle {
		// è™šæ‹ŸSinglesä¸“è¾‘ï¼šä½¿ç”¨ä¸»è¦è‰ºæœ¯å®¶åï¼ˆå¤„ç†åˆä½œè€…æƒ…å†µï¼‰
		singlesFolder := core.Config.VirtualSinglesFolderName
		if singlesFolder == "" {
			singlesFolder = "Singles"
		}
		// æå–ä¸»è¦è‰ºæœ¯å®¶ï¼ˆå¤„ç†åˆä½œè€…ï¼šå–ç¬¬ä¸€ä¸ª&ä¹‹å‰çš„åå­—ï¼‰
		primaryArtist := core.GetPrimaryArtist(meta.Data[0].Attributes.ArtistName)
		// æ ¼å¼: "Olivia Rodrigo - Singles"
		albumFoldername = fmt.Sprintf("%s - %s", core.LimitString(primaryArtist), singlesFolder)
	} else {
		albumFoldername = strings.NewReplacer(
			"{ReleaseDate}", meta.Data[0].Attributes.ReleaseDate, "{ReleaseYear}", meta.Data[0].Attributes.ReleaseDate[:4],
			"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName), "{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
			"{UPC}", meta.Data[0].Attributes.Upc, "{RecordLabel}", meta.Data[0].Attributes.RecordLabel,
			"{Copyright}", meta.Data[0].Attributes.Copyright, "{AlbumId}", albumId,
			"{Quality}", Quality, "{Codec}", Codec, "{Tag}", Album_Tag_string,
		).Replace(core.Config.AlbumFolderFormat)
	}

	sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
	sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")

	var longestFilename string
	for i := range meta.Data[0].Relationships.Tracks.Data {
		if len(meta.Data[0].Relationships.Tracks.Data[i].Attributes.Name) > len(longestFilename) {
			longestFilename = meta.Data[0].Relationships.Tracks.Data[i].Attributes.Name
		}
	}
	longestFilename = strings.NewReplacer(
		"{SongName}", longestFilename,
		"{SongNumer}", "99",
		"{Quality}", "24B-192.0kHz",
		"{Tag}", core.Config.AppleMasterChoice+" "+core.Config.ExplicitChoice,
		"{Codec}", "ATMOS",
	).Replace(core.Config.SongFileFormat) + ".m4a"

	finalArtistDir, finalAlbumDir, _ := utils.EnsureSafePath(baseSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, longestFilename)

	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveFolder, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveFolder
	}
	finalAlbumFolder := filepath.Join(finalSingerFolder, finalAlbumDir)
	if err := os.MkdirAll(finalAlbumFolder, 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºä¸“è¾‘ç›®å½•å¤±è´¥: %w", err)
	}

	core.SafePrintf("ğŸ¤ æ­Œæ‰‹: %s\n", meta.Data[0].Attributes.ArtistName)
	core.SafePrintf("ğŸ’½ ä¸“è¾‘: %s\n", meta.Data[0].Attributes.Name)

	if core.Config.SaveArtistCover && !(strings.Contains(albumId, "pl.")) {
		if len(meta.Data[0].Relationships.Artists.Data) > 0 {
			_, err = metadata.WriteCover(finalSingerFolder, "folder", meta.Data[0].Relationships.Artists.Data[0].Attributes.Artwork.Url)
			if err != nil {
			}
		}
	}
	// å¤„ç†ä¸“è¾‘å°é¢
	if isSingle {
		// å¯¹äºè™šæ‹ŸSinglesä¸“è¾‘ï¼Œä¸ä¸‹è½½ç»Ÿä¸€çš„å°é¢æ–‡ä»¶
		// æ¯ä¸ªå•æ›²ä¼šåœ¨downloadTrackSilentlyä¸­ä¿å­˜è‡ªå·±ç‹¬ç«‹çš„å°é¢ï¼ˆæ–‡ä»¶åä¸m4aä¸€è‡´ï¼‰
		// covPath ä¿æŒç©ºå€¼ï¼ŒdownloadTrackSilently ä¼šä¸ºæ¯ä¸ªå•æ›²å•ç‹¬ä¸‹è½½å°é¢
		covPath = ""
	} else {
		// éè™šæ‹ŸSinglesä¸“è¾‘ï¼Œä¸‹è½½ç»Ÿä¸€çš„ä¸“è¾‘å°é¢
		var err error
		covPath, err = metadata.WriteCover(finalAlbumFolder, "cover", meta.Data[0].Attributes.Artwork.URL)
		if err != nil {
		}
	}
	if core.Config.SaveAnimatedArtwork && meta.Data[0].Attributes.EditorialVideo.MotionDetailSquare.Video != "" {
		motionvideoUrlSquare, _, err := parser.ExtractVideo(meta.Data[0].Attributes.EditorialVideo.MotionDetailSquare.Video)
		if err == nil {
			exists, _ := utils.FileExists(filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"))
			if !exists {
				cmd := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", motionvideoUrlSquare, "-c", "copy", filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"))
				_ = cmd.Run()
			}
		}

		if core.Config.EmbyAnimatedArtwork {
			cmd3 := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", filepath.Join(finalAlbumFolder, "square_animated_artwork.mp4"), "-vf", "scale=440:-1", "-r", "24", "-f", "gif", filepath.Join(finalAlbumFolder, "folder.jpg"))
			_ = cmd3.Run()
		}

		motionvideoUrlTall, _, err := parser.ExtractVideo(meta.Data[0].Attributes.EditorialVideo.MotionDetailTall.Video)
		if err == nil {
			exists, _ := utils.FileExists(filepath.Join(finalAlbumFolder, "tall_animated_artwork.mp4"))
			if !exists {
				cmd := exec.Command("ffmpeg", "-loglevel", "quiet", "-y", "-i", motionvideoUrlTall, "-c", "copy", filepath.Join(finalAlbumFolder, "tall_animated_artwork.mp4"))
				_ = cmd.Run()
			}
		}
	}

	// SelectTrackså¯èƒ½æ¶‰åŠäº¤äº’å¼è¾“å…¥ï¼Œæš‚åœUI
	if !core.DisableDynamicUI && core.Dl_select {
		ui.Suspend()
	}
	selected := ui.SelectTracks(meta, storefront, urlArg_i)
	if !core.DisableDynamicUI && core.Dl_select {
		ui.Resume()
	}

	core.SafePrintln("ğŸ”¬ æ­£åœ¨è¿›è¡Œç‰ˆæƒé¢„æ£€ï¼Œè¯·ç¨å€™...")
	var workingAccounts []structs.Account
	if len(meta.Data[0].Relationships.Tracks.Data) > 0 {
		firstTrackId := meta.Data[0].Relationships.Tracks.Data[0].ID
		for _, acc := range core.Config.Accounts {
			_, err := api.GetInfoFromAdam(firstTrackId, &acc, acc.Storefront)
			if err == nil {
				workingAccounts = append(workingAccounts, acc)
			} else {
				core.SafePrintf("è´¦æˆ· [%s] æ— æ³•è®¿é—®æ­¤ä¸“è¾‘ (å¯èƒ½æ— ç‰ˆæƒ)ï¼Œæœ¬æ¬¡ä»»åŠ¡å°†è·³è¿‡è¯¥è´¦æˆ·ã€‚\n", acc.Name)
			}
		}
	} else {
		return errors.New("ä¸“è¾‘ä¸­æ²¡æœ‰æ›²ç›®")
	}

	if len(workingAccounts) == 0 {
		return errors.New("æ‰€æœ‰è´¦æˆ·å‡æ— æ³•è®¿é—®æ­¤ä¸“è¾‘ï¼Œä»»åŠ¡ä¸­æ­¢")
	}

	albumQualityType := "AAC"
	albumQualityString := "AAC"

	// Priority 1: Respect user's explicit quality choice for display
	if core.Dl_atmos {
		albumQualityType = "Dolby Atmos"
		albumQualityString = "Dolby Atmos"
	} else if core.Dl_aac && *core.Aac_type == "aac-binaural" {
		albumQualityType = "AAC Binaural"
		albumQualityString = "AAC Binaural"
	} else if core.Dl_aac && *core.Aac_type == "aac-downmix" {
		albumQualityType = "AAC Downmix"
		albumQualityString = "AAC Downmix"
	} else if core.Dl_aac && *core.Aac_type == "aac-lc" {
		albumQualityType = "AAC 256"
		albumQualityString = "AAC 256"
	} else if core.Dl_aac {
		// Generic AAC mode - check if user wants specific type
		if *core.Aac_type != "aac" {
			albumQualityType = "AAC " + strings.Title(*core.Aac_type)
			albumQualityString = "AAC " + strings.Title(*core.Aac_type)
		} else {
			albumQualityType = "AAC"
			albumQualityString = "AAC"
		}
	} else {
		// Priority 2: Auto-detect quality for display when user didn't specify
		// isHires and isLossless already declared earlier, just reset them
		isHires = false
		isLossless = false

		for _, trackIndex := range selected {
			track := meta.Data[0].Relationships.Tracks.Data[trackIndex-1]
			if utils.Contains(track.Attributes.AudioTraits, "hi-res-lossless") {
				isHires = true
				break
			}
			if utils.Contains(track.Attributes.AudioTraits, "lossless") {
				isLossless = true
			}
		}

		if isHires {
			albumQualityType = "Hi-Res Lossless"
			albumQualityString = "Hi-Res Lossless"
			// Update Album_Tag_string for Hi-Res Lossless
			if !core.Dl_atmos && !core.Dl_aac {
				Album_Tag_string = utils.FormatQualityTag("Hi-Res Lossless")
			}
		} else if isLossless {
			albumQualityType = "Lossless"
			albumQualityString = "Lossless"
			// Alac tag is already set as default for lossless
		}
	}

	var numThreads int
	switch albumQualityType {
	case "Hi-Res Lossless":
		numThreads = core.Config.HiresDownloadThreads
	case "Lossless":
		numThreads = core.Config.LosslessDownloadThreads
	default: // "AAC"
		numThreads = core.Config.AacDownloadThreads
	}

	if numThreads < 1 {
		numThreads = 1
	}

	regionSet := make(map[string]bool)
	for _, acc := range workingAccounts {
		if acc.Storefront != "" {
			regionSet[strings.ToUpper(acc.Storefront)] = true
		}
	}
	var regionNames []string
	for r := range regionSet {
		regionNames = append(regionNames, r)
	}
	sort.Strings(regionNames)
	regionsStr := strings.Join(regionNames, " / ")

	yellow := color.New(color.FgYellow).SprintFunc()
	green := color.New(color.FgGreen).SprintFunc()
	core.SafePrintf("%s %s | %s | %s | %s\n",
		green("ğŸ“¡ éŸ³æº:"),
		green(albumQualityString),
		green(fmt.Sprintf("%d çº¿ç¨‹", numThreads)),
		yellow(regionsStr),
		green(fmt.Sprintf("%d ä¸ªè´¦æˆ·å¹¶è¡Œä¸‹è½½", len(workingAccounts))),
	)
	core.SafePrintln(strings.Repeat("-", 45))

	core.RipLock.Lock()
	defer core.RipLock.Unlock()

	// å¼ºåˆ¶ä¸‹è½½æ¨¡å¼ä¸‹è·³è¿‡æ–‡ä»¶å­˜åœ¨æ€§é¢„æ£€
	if !core.ForceDownload {
		// å¿«é€Ÿæ£€æŸ¥æ‰€æœ‰æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆä»…æ–‡ä»¶ç³»ç»Ÿæ£€æŸ¥ï¼Œä¸è¯»å–å†…å®¹ï¼‰
		var checkSaveFolder string
		if usingCache {
			checkSaveFolder = finalSaveFolder // ä½¿ç”¨ç¼“å­˜æ—¶æ£€æŸ¥æœ€ç»ˆç›®æ ‡è·¯å¾„
		} else {
			checkSaveFolder = baseSaveFolder
		}

		// æ„å»ºæ‰€æœ‰éœ€è¦æ£€æŸ¥çš„æ–‡ä»¶è·¯å¾„
		type trackFileInfo struct {
			trackNum int
			filePath string
			duration int
		}
		var filesToCheck []trackFileInfo

		for _, trackNum := range selected {
			track := meta.Data[0].Relationships.Tracks.Data[trackNum-1]

			// å¿«é€Ÿæ„å»ºæ–‡ä»¶è·¯å¾„
			var singerFoldername, albumFoldername string
			if core.Config.ArtistFolderFormat != "" {
				if strings.Contains(albumId, "pl.") {
					singerFoldername = strings.NewReplacer(
						"{ArtistName}", "Apple Music", "{ArtistId}", "", "{UrlArtistName}", "Apple Music",
					).Replace(core.Config.ArtistFolderFormat)
				} else if len(meta.Data[0].Relationships.Artists.Data) > 0 {
					singerFoldername = strings.NewReplacer(
						"{UrlArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
						"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
						"{ArtistId}", meta.Data[0].Relationships.Artists.Data[0].ID,
					).Replace(core.Config.ArtistFolderFormat)
				}
			}

			if strings.Contains(albumId, "pl.") {
				albumFoldername = strings.NewReplacer(
					"{PlaylistName}", core.LimitString(meta.Data[0].Attributes.Name),
					"{PlaylistId}", albumId,
				).Replace(core.Config.PlaylistFolderFormat)
			} else if isSingle {
				// è™šæ‹ŸSinglesä¸“è¾‘ï¼šä½¿ç”¨ä¸»è¦è‰ºæœ¯å®¶åï¼ˆå¤„ç†åˆä½œè€…æƒ…å†µï¼‰
				singlesFolder := core.Config.VirtualSinglesFolderName
				if singlesFolder == "" {
					singlesFolder = "Singles"
				}
				// æå–ä¸»è¦è‰ºæœ¯å®¶ï¼ˆå¤„ç†åˆä½œè€…ï¼šå–ç¬¬ä¸€ä¸ª&ä¹‹å‰çš„åå­—ï¼‰
				primaryArtist := core.GetPrimaryArtist(meta.Data[0].Attributes.ArtistName)
				// æ ¼å¼: "Olivia Rodrigo - Singles"
				albumFoldername = fmt.Sprintf("%s - %s", core.LimitString(primaryArtist), singlesFolder)
			} else {
				albumFoldername = strings.NewReplacer(
					"{ArtistName}", core.LimitString(meta.Data[0].Attributes.ArtistName),
					"{AlbumName}", core.LimitString(meta.Data[0].Attributes.Name),
					"{AlbumId}", albumId,
				).Replace(core.Config.AlbumFolderFormat)
			}

			songName := strings.NewReplacer(
				"{SongNumer}", fmt.Sprintf("%02d", trackNum),
				"{SongName}", core.LimitString(track.Attributes.Name),
			).Replace(core.Config.SongFileFormat)

			sanitizedSingerFolder := core.ForbiddenNames.ReplaceAllString(singerFoldername, "_")
			sanitizedAlbumFolder := core.ForbiddenNames.ReplaceAllString(albumFoldername, "_")
			sanitizedSongName := core.ForbiddenNames.ReplaceAllString(songName, "_")
			filenameWithExt := fmt.Sprintf("%s.m4a", sanitizedSongName)

			checkArtistDir, checkAlbumDir, checkFilename := utils.EnsureSafePath(checkSaveFolder, sanitizedSingerFolder, sanitizedAlbumFolder, filenameWithExt)
			var checkSingerFolder string
			if checkArtistDir != "" {
				checkSingerFolder = filepath.Join(checkSaveFolder, checkArtistDir)
			} else {
				checkSingerFolder = checkSaveFolder
			}
			checkAlbumFolder := filepath.Join(checkSingerFolder, checkAlbumDir)
			checkFilePath := filepath.Join(checkAlbumFolder, checkFilename)

			filesToCheck = append(filesToCheck, trackFileInfo{
				trackNum: trackNum,
				filePath: checkFilePath,
				duration: track.Attributes.DurationInMillis,
			})
		}

		// ä½¿ç”¨å¹¶å‘æ‰¹é‡æ ¡éªŒæˆ–ä¸²è¡Œæ ¡éªŒ
		allFilesExist := true
		if core.Config.FileValidation.ConcurrentCheckEnabled && len(filesToCheck) > 1 {
			// å¹¶å‘æ‰¹é‡æ ¡éªŒ
			logger.Debug("[æ–‡ä»¶æ ¡éªŒ] ä½¿ç”¨å¹¶å‘æ¨¡å¼æ£€æŸ¥ %d ä¸ªæ–‡ä»¶ (workeræ•°: %d)",
				len(filesToCheck), core.Config.FileValidation.ConcurrentWorkers)

			paths := make([]string, len(filesToCheck))
			for i, info := range filesToCheck {
				paths[i] = info.filePath
			}

			// ä¼°ç®—æœ€å°æ–‡ä»¶å¤§å°
			var minSize int64
			if core.Config.FileValidation.SizeCheckEnabled && len(filesToCheck) > 0 {
				minSize = utils.EstimateFileSize(Codec, core.Dl_atmos, filesToCheck[0].duration)
				logger.Debug("[æ–‡ä»¶æ ¡éªŒ] æœ€å°æ–‡ä»¶å¤§å°: %d å­—èŠ‚ (~%.1f MB)", minSize, float64(minSize)/(1024*1024))
			}

			results := utils.ValidateFilesBatch(paths, minSize, core.Config.FileValidation.ConcurrentWorkers)
			for _, validation := range results {
				if !validation.Exists || !validation.IsValid {
					allFilesExist = false
					break
				}
			}
		} else {
			// ä¸²è¡Œæ ¡éªŒï¼ˆå‘åå…¼å®¹ï¼‰
			for _, info := range filesToCheck {
				var minSize int64
				if core.Config.FileValidation.SizeCheckEnabled {
					minSize = utils.EstimateFileSize(Codec, core.Dl_atmos, info.duration)
				}

				validation, _ := utils.ValidateFile(info.filePath, minSize)
				if !validation.Exists || !validation.IsValid {
					allFilesExist = false
					break
				}
			}
		}

		// å¦‚æœæ‰€æœ‰æ–‡ä»¶éƒ½å·²å­˜åœ¨ï¼Œç›´æ¥è·³è¿‡
		if allFilesExist && len(selected) > 0 {
			green := color.New(color.FgGreen).SprintFunc()
			core.SafePrintln(green("âœ… æ‰€æœ‰æ–‡ä»¶å·²å­˜åœ¨ï¼Œä»»åŠ¡å®Œæˆï¼"))
			// æ ‡è®°æ‰€æœ‰æ–‡ä»¶ä¸ºå·²å®Œæˆ
			for _, trackNum := range selected {
				core.SharedLock.Lock()
				core.OkDict[albumId] = append(core.OkDict[albumId], trackNum)
				core.Counter.Total++
				core.Counter.Success++
				core.SharedLock.Unlock()
			}

			// æ¸…ç†å¯èƒ½å­˜åœ¨çš„ç¼“å­˜ç›®å½•ï¼ˆé¿å…åç»­è½¬ç§»æµç¨‹ï¼‰
			if usingCache {
				cacheHashDir := baseSaveFolder
				if err := utils.CleanupCacheDirectory(cacheHashDir); err != nil {
					logger.Debug("[ç¼“å­˜æ¸…ç†] æ¸…ç†ç¼“å­˜ç›®å½•: %v", err)
				} else {
					logger.Debug("[ç¼“å­˜æ¸…ç†] å·²æ¸…ç†å¯èƒ½å­˜åœ¨çš„ç¼“å­˜ç›®å½•")
				}
			}

			return nil
		}
	} else {
		core.SafePrintf("ğŸ’ª å¼ºåˆ¶ä¸‹è½½æ¨¡å¼ï¼šå°†è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶\n")
	}

	// ä½¿ç”¨æ‰¹æ¬¡è¿­ä»£å™¨è¿›è¡Œæ•°æ®å±‚åˆ†æ‰¹å¤„ç†
	batchIterator := structs.NewBatchIterator(selected, core.Config.BatchSize)

	for batch, hasMore := batchIterator.Next(); hasMore; batch, hasMore = batchIterator.Next() {
		// æ˜¾ç¤ºæ‰¹æ¬¡å¼€å§‹ä¿¡æ¯ï¼ˆå¤šæ‰¹æ¬¡æ—¶ï¼‰
		if batch.TotalBatches > 1 {
			if !core.DisableDynamicUI {
				ui.Suspend()
			}
			cyan := color.New(color.FgCyan).SprintFunc()
			core.SafePrintf("%s\n", cyan(fmt.Sprintf("ğŸ“¦ æ‰¹æ¬¡ %d/%dï¼ˆ%d é¦–ï¼‰", batch.BatchNum, batch.TotalBatches, batch.BatchSize)))
			if !core.DisableDynamicUI {
				ui.Resume()
			}
		}

		// åˆå§‹åŒ–å½“å‰æ‰¹æ¬¡çš„ TrackStatuses
		core.TrackStatuses = make([]core.TrackStatus, len(batch.Tracks))
		for i, trackNum := range batch.Tracks {
			track := meta.Data[0].Relationships.Tracks.Data[trackNum-1]

			// è·³è¿‡ music-videos çš„è´¨é‡æ£€æµ‹
			quality := "N/A"
			if track.Type == "music-videos" {
				quality = "MV"
			} else {
				manifest, err := api.GetInfoFromAdam(track.ID, mainAccount, storefront)
				if err == nil && manifest.Attributes.ExtendedAssetUrls.EnhancedHls != "" {
					_, _, quality, err = parser.ExtractMedia(manifest.Attributes.ExtendedAssetUrls.EnhancedHls, false)
					if err != nil {
						quality = "è·å–å¤±è´¥"
					}
				} else {
					quality = "AAC 256kbps"
				}
			}

			core.TrackStatuses[i] = core.TrackStatus{
				Index:       i,
				TrackNum:    trackNum,
				TrackTotal:  len(meta.Data[0].Relationships.Tracks.Data),
				TrackName:   track.Attributes.Name,
				Quality:     fmt.Sprintf("(%s)", quality),
				Status:      "ç­‰å¾…ä¸­",
				StatusColor: color.New(color.FgWhite).SprintFunc(),
			}
		}

		doneUI := make(chan struct{})
		// åªæœ‰åœ¨æœªç¦ç”¨åŠ¨æ€UIæ—¶æ‰å¯åŠ¨UIæ¸²æŸ“
		if !core.DisableDynamicUI {
			// åŠ¨æ€UIæœŸé—´ï¼šå°†loggerè¾“å‡ºé‡å®šå‘åˆ°stderrï¼Œé¿å…å¹²æ‰°å…‰æ ‡å®šä½
			// UIä½¿ç”¨stdoutè¾“å‡ºï¼ˆå¸¦å…‰æ ‡ç§»åŠ¨ï¼‰ï¼Œloggerä½¿ç”¨stderrï¼Œäº’ä¸å¹²æ‰°
			logger.SetOutput(os.Stderr)
			go ui.RenderUI(doneUI)
		}

		var wg sync.WaitGroup
		semaphore := make(chan struct{}, numThreads)

		for i, trackNum := range batch.Tracks {
			wg.Add(1)
			go func(trackIndexInMeta int, statusIndex int) {
				semaphore <- struct{}{}
				defer func() {
					<-semaphore
					wg.Done()
				}()

				trackData := meta.Data[0].Relationships.Tracks.Data[trackIndexInMeta-1]

				core.SharedLock.Lock()
				isDone := utils.IsInArray(core.OkDict[albumId], trackIndexInMeta)
				core.SharedLock.Unlock()

				if isDone {
					if notifier != nil {
						notifier.NotifyStatus(statusIndex, "å·²å­˜åœ¨", "skipped")
					}
					core.SharedLock.Lock()
					core.Counter.Total++
					core.Counter.Success++
					core.SharedLock.Unlock()
					return
				}

				red := color.New(color.FgRed).SprintFunc()
				yellow := color.New(color.FgYellow).SprintFunc()

				const PostDownloadMaxRetries = 3

				for attempt := 1; attempt <= PostDownloadMaxRetries; attempt++ {
					// é‡è¯•ä¿¡æ¯ç§»åˆ°é”™è¯¯å¤„ç†éƒ¨åˆ†ç»Ÿä¸€æ˜¾ç¤º

					// ä½¿ç”¨é€‚é…å™¨æ¨¡å¼ï¼šæ—§çš„progressChanæœºåˆ¶è‡ªåŠ¨è½¬æ¢ä¸ºæ–°çš„äº‹ä»¶ç³»ç»Ÿ
					var progressChan chan runv14.ProgressUpdate
					if notifier != nil {
						adapter := progress.NewProgressAdapter(notifier, statusIndex, "download")
						ch := make(chan runv14.ProgressUpdate, 10)
						// å¯åŠ¨é€‚é…å™¨
						go func() {
							adaptCh := adapter.ToRunv14Chan()
							for p := range ch {
								adaptCh <- p
							}
							close(adaptCh)
						}()
						progressChan = ch
					} else {
						// é™çº§ï¼šå¦‚æœæ²¡æœ‰notifierï¼Œä»ä½¿ç”¨æ—§æ–¹å¼
						ch := make(chan runv14.ProgressUpdate, 10)
						go func() {
							for p := range ch {
								speedStr := utils.FormatSpeed(p.SpeedBPS)
								account := &workingAccounts[statusIndex%len(workingAccounts)]
								accountInfo := fmt.Sprintf("%s è´¦å·", strings.ToUpper(account.Storefront))
								var status string
								if p.Stage == "decrypt" {
									status = fmt.Sprintf("%s %s %d%% (%s)", yellow(accountInfo), red("è§£å¯†ä¸­"), p.Percentage, speedStr)
								} else {
									status = fmt.Sprintf("%s ä¸‹è½½ä¸­ %d%% (%s)", yellow(accountInfo), p.Percentage, speedStr)
								}
								ui.UpdateStatus(statusIndex, status, color.New(color.FgYellow).SprintFunc())
							}
						}()
						progressChan = ch
					}

					trackPath, err := downloadTrackWithFallback(trackData, meta, albumId, storefront, baseSaveFolder, finalSaveFolder, Codec, covPath, workingAccounts, statusIndex, statusIndex, ui.UpdateStatus, progressChan)
					close(progressChan)

					if err != nil {
						// downloadTrackWithFallback has its own retries. If it fails, we consider it a permanent failure for this track.

						// æˆªæ–­é”™è¯¯ä¿¡æ¯ï¼Œé¿å…æ¢è¡Œ
						errorMsg := err.Error()
						if len(errorMsg) > 50 {
							errorMsg = errorMsg[:47] + "..."
						}

						core.SharedLock.Lock()
						core.Counter.Total++
						// æ£€æŸ¥æ˜¯å¦æ˜¯è·³è¿‡ç±»å‹çš„é”™è¯¯
						if strings.Contains(err.Error(), "å·²è·³è¿‡") {
							if notifier != nil {
								notifier.NotifyStatus(statusIndex, errorMsg, "skipped")
							}
							// è·³è¿‡ä¸è®¡å…¥é”™è¯¯ç»Ÿè®¡
						} else {
							if notifier != nil {
								notifier.NotifyError(statusIndex, fmt.Errorf("ä¸‹è½½å¤±è´¥: %s", errorMsg))
							}
							core.Counter.Error++
						}
						core.SharedLock.Unlock()
						return
					}

					// æ£€æŸ¥æ˜¯å¦ä¸º"æ–‡ä»¶å·²å­˜åœ¨"çš„æƒ…å†µ
					fileAlreadyExists := false
					if strings.HasPrefix(trackPath, "EXISTS:") {
						fileAlreadyExists = true
						trackPath = strings.TrimPrefix(trackPath, "EXISTS:")
						logger.Debug("[è·³è¿‡] æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ— éœ€åç»­å¤„ç†: %s", trackPath)
					}

					var postDownloadError error
					wasFixed := false

					// Step 2: Re-encode if necessary (æ–‡ä»¶å·²å­˜åœ¨åˆ™è·³è¿‡)
					if !fileAlreadyExists && core.Config.FfmpegFix && trackData.Type != "music-videos" {
						isAAC := core.Dl_aac && *core.Aac_type == "aac-lc"
						if !isAAC {
							var fixErr error
							wasFixed, fixErr = checkAndReEncodeTrack(trackPath, statusIndex, notifier)
							if fixErr != nil {
								postDownloadError = fmt.Errorf("ä¿®å¤å¤±è´¥: %w", fixErr)
							}
						}
					}

					// Step 3: Write tags (only if previous step was successful and file is newly downloaded)
					if postDownloadError == nil && !fileAlreadyExists {
						var finalLrc string
						if lyricAccount != nil && (core.Config.EmbedLrc || core.Config.SaveLrcFile) && trackData.Type != "music-videos" {
							lrcStr, lrcErr := lyrics.Get(storefront, trackData.ID, core.Config.LrcType, core.Config.Language, core.Config.LrcFormat, core.DeveloperToken, lyricAccount.MediaUserToken)
							if lrcErr == nil {
								if core.Config.SaveLrcFile {
									lrcFilename := fmt.Sprintf("%s.lrc", strings.TrimSuffix(filepath.Base(trackPath), filepath.Ext(filepath.Base(trackPath))))
									_ = metadata.WriteLyrics(filepath.Dir(trackPath), lrcFilename, lrcStr)
								}
								if core.Config.EmbedLrc {
									finalLrc = lrcStr
								}
							}
						}

						// ä½¿ç”¨å¸¦è‡ªåŠ¨ä¿®å¤åŠŸèƒ½çš„æ ‡ç­¾å†™å…¥
						tagErr := metadata.WriteMP4TagsWithRetry(trackPath, finalLrc, meta, trackIndexInMeta, len(meta.Data[0].Relationships.Tracks.Data))
						if tagErr != nil {
							// AACæ–‡ä»¶æ ‡ç­¾å†™å…¥å¤±è´¥æ—¶ä¸åˆ é™¤æ–‡ä»¶ï¼ˆå› ä¸ºåŸºæœ¬æ ‡ç­¾å·²é€šè¿‡MP4Boxå†™å…¥ï¼‰
							if core.Dl_aac {
								logger.Warn("AACæ–‡ä»¶æ ‡ç­¾å†™å…¥å¤±è´¥ï¼Œä¿ç•™æ–‡ä»¶ï¼ˆå·²åŒ…å«åŸºæœ¬æ ‡ç­¾ï¼‰: %v", tagErr)
								// ä¸è®¾ç½® postDownloadErrorï¼Œç»§ç»­æ‰§è¡Œ
							} else {
								postDownloadError = fmt.Errorf("æ ‡ç­¾å†™å…¥å¤±è´¥: %w", tagErr)
							}
						}
					}

					// Check if any post-download step failed
					if postDownloadError != nil {
						os.Remove(trackPath) // Delete the problematic file

						// æˆªæ–­è¿‡é•¿çš„é”™è¯¯ä¿¡æ¯ï¼Œé¿å…æ¢è¡Œåˆ·å±
						errorMsg := postDownloadError.Error()
						if len(errorMsg) > 50 {
							errorMsg = errorMsg[:47] + "..."
						}

						if attempt < PostDownloadMaxRetries {
							// æ˜¾ç¤ºé‡è¯•ä¿¡æ¯ï¼ˆåŸåœ°æ›´æ–°ï¼Œä¸åˆ·å±ï¼‰
							if notifier != nil {
								notifier.NotifyStatus(statusIndex, fmt.Sprintf("é‡è¯• %d/%d: %s", attempt, PostDownloadMaxRetries, errorMsg), "retry")
							}
							time.Sleep(1500 * time.Millisecond) // ç¼©çŸ­ç­‰å¾…æ—¶é—´
							continue                            // Go to the next retry attempt
						} else {
							// æ‰€æœ‰é‡è¯•å¤±è´¥ï¼Œè·³è¿‡è¯¥æ›²ç›®ï¼ˆä¸è®¡å…¥é”™è¯¯è®¡æ•°ï¼‰
							if notifier != nil {
								notifier.NotifyStatus(statusIndex, "å·²è·³è¿‡ (æ ‡ç­¾å¤±è´¥)", "skipped")
							}
							core.SharedLock.Lock()
							core.Counter.Total++
							// ä¸å¢åŠ  Error è®¡æ•°ï¼Œè§†ä¸ºè·³è¿‡è€Œéé”™è¯¯
							core.SharedLock.Unlock()
							return
						}
					}

					// All steps successful
					core.SharedLock.Lock()
					core.Counter.Total++
					core.Counter.Success++
					if fileAlreadyExists {
						// æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ˜¾ç¤ºç‰¹æ®ŠçŠ¶æ€
						if notifier != nil {
							notifier.NotifyStatus(statusIndex, "âœ… æœ¬åœ°å·²å­˜åœ¨", "exists")
						}
					} else if wasFixed {
						if notifier != nil {
							notifier.NotifyStatus(statusIndex, "é‡ç¼–ç å®Œæˆ", "complete")
						}
					} else {
						if notifier != nil {
							notifier.NotifyComplete(statusIndex)
						}
					}
					core.SharedLock.Unlock()
					return // Mission accomplished, exit goroutine
				}
			}(trackNum, i)
		}

		wg.Wait()
		close(doneUI)
		time.Sleep(200 * time.Millisecond)
		ui.PrintUI(false) // æ‰¹æ¬¡å®Œæˆåçš„æœ€åä¸€æ¬¡æ‰“å°ï¼Œéé¦–æ¬¡æ›´æ–°

		// UIç»“æŸåï¼šæ¢å¤loggerè¾“å‡ºåˆ°stdout
		if !core.DisableDynamicUI {
			logger.SetOutput(os.Stdout)
		}

		// å¦‚æœä½¿ç”¨äº†ç¼“å­˜ï¼Œæ‰¹æ¬¡å®Œæˆåç«‹å³è½¬ç§»æ–‡ä»¶ï¼ˆå¤šæ‰¹æ¬¡ä¸”ä¸æ˜¯æœ€åä¸€æ‰¹ï¼‰
		if usingCache && batch.TotalBatches > 1 && !batch.IsLast {
			// æ£€æŸ¥ç¼“å­˜hashç›®å½•ä¸­æ˜¯å¦æœ‰æ–°æ–‡ä»¶éœ€è¦è½¬ç§»
			cacheHashDir := baseSaveFolder

			hasFilesToMove := false
			filepath.Walk(cacheHashDir, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return nil
				}
				if !info.IsDir() && strings.HasSuffix(path, ".m4a") {
					hasFilesToMove = true
					return filepath.SkipDir
				}
				return nil
			})

			if hasFilesToMove {
				// æœ‰æ–°æ–‡ä»¶ï¼Œéœ€è¦è½¬ç§»
				if !core.DisableDynamicUI {
					ui.Suspend()
				}
				cyan := color.New(color.FgCyan).SprintFunc()
				core.SafePrintf("%s\n", cyan(fmt.Sprintf("ğŸ“¤ æ‰¹æ¬¡ %d/%d: è½¬ç§»æ–‡ä»¶...", batch.BatchNum, batch.TotalBatches)))

				// é€’å½’è½¬ç§»æ‰€æœ‰æ–‡ä»¶
				moveCount := 0
				batchSkippedCount := 0
				filepath.Walk(cacheHashDir, func(cachePath string, info os.FileInfo, walkErr error) error {
					if walkErr != nil || cachePath == cacheHashDir {
						return nil
					}

					relPath, err := filepath.Rel(cacheHashDir, cachePath)
					if err != nil {
						return nil
					}

					targetPath := filepath.Join(finalSaveFolder, relPath)

					if info.IsDir() {
						// åˆ›å»ºç›®å½•æ—¶ä½¿ç”¨ 0755 æƒé™
						if err := os.MkdirAll(targetPath, 0755); err != nil {
							// ç›®å½•åˆ›å»ºå¤±è´¥ï¼Œè·³è¿‡
							return nil
						}
					} else if strings.HasSuffix(cachePath, ".m4a") || strings.HasSuffix(cachePath, ".jpg") {
						// SafeMoveFile å†…éƒ¨å·²æ£€æŸ¥ç›®æ ‡æ–‡ä»¶å­˜åœ¨æ€§
						if err := utils.SafeMoveFile(cachePath, targetPath); err != nil {
							if strings.Contains(err.Error(), "ç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨") {
								batchSkippedCount++
								// é™é»˜è·³è¿‡
							}
						} else {
							moveCount++
						}
					}
					return nil
				})

				if batchSkippedCount > 0 {
					core.SafePrintf("%s\n", color.New(color.FgGreen).SprintFunc()(fmt.Sprintf("âœ… æ‰¹æ¬¡ %d/%d: è½¬ç§»å®Œæˆï¼ˆæ–°å¢ %dï¼Œè·³è¿‡ %dï¼‰", batch.BatchNum, batch.TotalBatches, moveCount, batchSkippedCount)))
				} else {
					core.SafePrintf("%s\n", color.New(color.FgGreen).SprintFunc()(fmt.Sprintf("âœ… æ‰¹æ¬¡ %d/%d: è½¬ç§»å®Œæˆï¼ˆ%d ä¸ªï¼‰", batch.BatchNum, batch.TotalBatches, moveCount)))
				}
				if !core.DisableDynamicUI {
					ui.Resume()
				}
			}
		}

		// æ˜¾ç¤ºæ‰¹æ¬¡å®Œæˆä¿¡æ¯ï¼ˆå¤šæ‰¹æ¬¡æ—¶ï¼‰
		if batch.TotalBatches > 1 && !batch.IsLast {
			if !core.DisableDynamicUI {
				ui.Suspend()
			}
			green := color.New(color.FgGreen).SprintFunc()
			core.SafePrintf("%s\n", green(fmt.Sprintf("âœ… æ‰¹æ¬¡ %d/%d å®Œæˆ", batch.BatchNum, batch.TotalBatches)))
			time.Sleep(300 * time.Millisecond)
			if !core.DisableDynamicUI {
				ui.Resume()
			}
		}
	} // æ‰¹æ¬¡å¾ªç¯ç»“æŸ

	logger.Info("%s", strings.Repeat("-", 45))

	// åªæœ‰åœ¨ä¸‹è½½çœŸæ­£æˆåŠŸåæ‰è½¬ç§»ç¼“å­˜æ–‡ä»¶
	// ä¼˜åŒ–ï¼šæ£€æŸ¥ç¼“å­˜ç›®å½•æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨åˆ™ç›´æ¥è·³è¿‡
	if usingCache {
		cacheHashDir := baseSaveFolder // ç¼“å­˜çš„hashå­ç›®å½•ï¼Œå¦‚: Cache/07b01b1d847fa876

		// å¿«é€Ÿæ£€æŸ¥ï¼šç¼“å­˜ç›®å½•æ˜¯å¦å­˜åœ¨
		cacheInfo, err := os.Stat(cacheHashDir)
		if err != nil || !cacheInfo.IsDir() {
			// ç¼“å­˜ç›®å½•ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®ï¼Œè·³è¿‡è½¬ç§»
			logger.Debug("[æ–‡ä»¶è½¬ç§»] ç¼“å­˜ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡è½¬ç§»: %s", cacheHashDir)
			downloadSuccess = true
			return nil
		}

		// ç»Ÿè®¡éœ€è¦è½¬ç§»çš„æ–‡ä»¶ï¼ˆä¼˜åŒ–ï¼šä¸€æ¬¡æ‰«æå®Œæˆç»Ÿè®¡å’Œæ£€æµ‹ï¼‰
		actualMusicFiles := 0
		hasFilesToMove := false
		filepath.Walk(cacheHashDir, func(path string, info os.FileInfo, err error) error {
			if err != nil || path == cacheHashDir {
				return nil
			}
			if !info.IsDir() {
				if strings.HasSuffix(path, ".m4a") || strings.HasSuffix(path, ".mp3") || strings.HasSuffix(path, ".mp4") {
					actualMusicFiles++
					hasFilesToMove = true
				} else if strings.HasSuffix(path, ".jpg") {
					hasFilesToMove = true
				}
			}
			// æ‰¾åˆ°ç¬¬ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶åå°±å¯ä»¥æå‰ç»ˆæ­¢éå†ï¼ˆä¼˜åŒ–ï¼‰
			if actualMusicFiles > 0 {
				return filepath.SkipDir
			}
			return nil
		})

		if hasFilesToMove {
			// æœ‰æ–‡ä»¶éœ€è¦è½¬ç§»
			cyan := color.New(color.FgCyan).SprintFunc()
			if actualMusicFiles > 0 {
				logger.Info("%s", cyan(fmt.Sprintf("ğŸ“¤ è½¬ç§» %d ä¸ªæ–‡ä»¶...", actualMusicFiles)))
			} else {
				logger.Info("%s", cyan("ğŸ“¤ è½¬ç§»æ–‡ä»¶..."))
			}

			// é€’å½’è½¬ç§»æ‰€æœ‰å­ç›®å½•
			movedCount := 0
			skippedCount := 0
			moveErr := filepath.Walk(cacheHashDir, func(cachePath string, info os.FileInfo, walkErr error) error {
				if walkErr != nil {
					return nil
				}

				// è·³è¿‡æ ¹ç›®å½•æœ¬èº«
				if cachePath == cacheHashDir {
					return nil
				}

				// è®¡ç®—ç›¸å¯¹è·¯å¾„
				relPath, err := filepath.Rel(cacheHashDir, cachePath)
				if err != nil {
					return nil
				}

				// æ„å»ºç›®æ ‡è·¯å¾„
				targetPath := filepath.Join(finalSaveFolder, relPath)

				if info.IsDir() {
					// åˆ›å»ºç›®æ ‡ç›®å½•
					return os.MkdirAll(targetPath, info.Mode())
				}

				// è½¬ç§»æ–‡ä»¶ï¼ˆSafeMoveFile å†…éƒ¨å·²æ£€æŸ¥ç›®æ ‡æ–‡ä»¶å­˜åœ¨æ€§ï¼‰
				if err := utils.SafeMoveFile(cachePath, targetPath); err != nil {
					if strings.Contains(err.Error(), "ç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨") {
						skippedCount++
						// é™é»˜è·³è¿‡ï¼Œä¸æ‰“å°è­¦å‘Š
					} else {
						logger.Warn("è­¦å‘Š: è½¬ç§»æ–‡ä»¶å¤±è´¥ %s: %v", relPath, err)
					}
				} else {
					movedCount++
				}
				return nil
			})

			if moveErr != nil {
				logger.Warn("è­¦å‘Š: è½¬ç§»æ–‡ä»¶è¿‡ç¨‹å‡ºç°é”™è¯¯: %v", moveErr)
			}

			// æ˜¾ç¤ºè½¬ç§»ç»“æœï¼ˆåªæœ‰å®é™…è½¬ç§»äº†æ–‡ä»¶æ‰æ˜¾ç¤ºï¼‰
			if movedCount > 0 {
				if skippedCount > 0 {
					msg := fmt.Sprintf("âœ… è½¬ç§»å®Œæˆï¼ˆæ–°å¢ %dï¼Œè·³è¿‡ %dï¼‰", movedCount, skippedCount)
					logger.Info("%s", color.New(color.FgGreen).SprintFunc()(msg))
				} else {
					msg := fmt.Sprintf("âœ… è½¬ç§»å®Œæˆï¼ˆ%d ä¸ªï¼‰", movedCount)
					logger.Info("%s", color.New(color.FgGreen).SprintFunc()(msg))
				}
			}
		}

		// æ¸…ç†ç¼“å­˜hashç›®å½•ï¼ˆæ— è®ºæˆåŠŸå¤±è´¥éƒ½æ¸…ç†ï¼‰
		if err := utils.CleanupCacheDirectory(cacheHashDir); err != nil {
			logger.Warn("æ¸…ç†ç¼“å­˜ç›®å½•è­¦å‘Š: %v", err)
		}

		// è®¾ç½®ä¸‹è½½æˆåŠŸæ ‡å¿—
		downloadSuccess = true
	} else {
		// æ²¡æœ‰ä½¿ç”¨ç¼“å­˜ï¼Œè®¾ç½®æˆåŠŸæ ‡å¿—
		downloadSuccess = true
	}

	// æ¸…ç†åªåŒ…å«å°é¢å›¾ç‰‡çš„ç©ºæ–‡ä»¶å¤¹ï¼ˆç”±äºéŸ³è´¨æ ‡ç­¾ä¸ä¸€è‡´äº§ç”Ÿçš„å†—ä½™æ–‡ä»¶å¤¹ï¼‰
	cleanedCount := cleanupEmptyAlbumFolders(finalSaveFolder)
	if cleanedCount > 0 {
		cyan := color.New(color.FgCyan).SprintFunc()
		logger.Info("%s", cyan(fmt.Sprintf("ğŸ§¹ å·²æ¸…ç† %d ä¸ªå†—ä½™ç©ºæ–‡ä»¶å¤¹", cleanedCount)))
	}

	return nil
}

func MvDownloader(adamID string, baseSaveDir, artistDir, albumDir string, storefront string, meta *structs.AutoGenerated, account *structs.Account) (string, string, error) {
	MVInfo, err := api.GetMVInfoFromAdam(adamID, account, storefront)
	if err != nil {
		return "", "", err
	}

	var trackTotal int
	var trackNum int
	var index int
	if meta != nil {
		trackTotal = len(meta.Data[0].Relationships.Tracks.Data)
		for i, track := range meta.Data[0].Relationships.Tracks.Data {
			if adamID == track.ID {
				index = i
				trackNum = i + 1
			}
		}
	}

	// Extract release year for Emby naming standard
	var releaseYear string
	if len(MVInfo.Data[0].Attributes.ReleaseDate) >= 4 {
		releaseYear = MVInfo.Data[0].Attributes.ReleaseDate[:4]
	}

	// Emby naming standard: {VideoName (Year)}/{VideoName (Year)}.mp4
	// Artist name is already in the parent folder, no need to repeat
	var mvFolderName, mvFileName string
	mvName := core.LimitString(MVInfo.Data[0].Attributes.Name)

	if releaseYear != "" {
		// Format: "VideoName (Year)"
		mvFolderName = fmt.Sprintf("%s (%s)", mvName, releaseYear)
		mvFileName = fmt.Sprintf("%s (%s).mp4", mvName, releaseYear)
	} else {
		// Fallback without year
		mvFolderName = mvName
		mvFileName = fmt.Sprintf("%s.mp4", mvName)
	}

	sanitizedMvFolderName := core.ForbiddenNames.ReplaceAllString(mvFolderName, "_")
	sanitizedMvFileName := core.ForbiddenNames.ReplaceAllString(mvFileName, "_")

	// Use artistDir as sub-folder under MV save folder for organization
	finalArtistDir, finalMvDir, finalFilename := utils.EnsureSafePath(
		baseSaveDir, artistDir, sanitizedMvFolderName, sanitizedMvFileName,
	)

	// Build the final Emby-compatible path structure
	var finalSingerFolder string
	if finalArtistDir != "" {
		finalSingerFolder = filepath.Join(baseSaveDir, finalArtistDir)
	} else {
		finalSingerFolder = baseSaveDir
	}
	finalMvFolder := filepath.Join(finalSingerFolder, finalMvDir)
	mvOutPath := filepath.Join(finalMvFolder, finalFilename)
	if err := os.MkdirAll(finalMvFolder, 0755); err != nil {
		return "", "", fmt.Errorf("åˆ›å»ºMVç›®å½•å¤±è´¥: %w", err)
	}
	exists, _ := utils.FileExists(mvOutPath)
	if exists {
		return mvOutPath, "å·²å­˜åœ¨", nil
	}

	mvm3u8url, _, err := runv3.GetWebplayback(adamID, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", "", fmt.Errorf("è·å–MVæ’­æ”¾åˆ—è¡¨å¤±è´¥: %w", err)
	}
	if mvm3u8url == "" {
		return "", "", errors.New("media-user-token may be wrong or expired")
	}

	vidPath := filepath.Join(finalMvFolder, fmt.Sprintf("%s_vid.mp4", adamID))
	audPath := filepath.Join(finalMvFolder, fmt.Sprintf("%s_aud.mp4", adamID))

	videom3u8url, resolution, err := parser.ExtractVideo(mvm3u8url)
	if err != nil {
		return "", "", fmt.Errorf("æå–è§†é¢‘æµURLå¤±è´¥: %w", err)
	}

	// æ˜¾ç¤ºè§†é¢‘è´¨é‡ä¿¡æ¯
	if resolution != "" {
		core.SafePrintf("ğŸ“º è§†é¢‘è´¨é‡: %s\n", resolution)
	}

	// æ˜¾ç¤ºä¸‹è½½å¼€å§‹æç¤º
	core.SafePrintf("ğŸ¥ å¼€å§‹ä¸‹è½½MV...\n")

	videokeyAndUrls, err := runv3.Run(adamID, videom3u8url, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", "", fmt.Errorf("è·å–è§†é¢‘å¯†é’¥å’ŒURLå¤±è´¥: %w", err)
	}
	err = runv3.ExtMvDataWithDesc(videokeyAndUrls, vidPath, "  ğŸ“¹ è§†é¢‘æµ")
	if err != nil {
		return "", "", fmt.Errorf("ä¸‹è½½æˆ–è§£å¯†è§†é¢‘æ•°æ®å¤±è´¥: %w", err)
	}

	audiom3u8url, err := parser.ExtractMvAudio(mvm3u8url)
	if err != nil {
		return "", "", fmt.Errorf("æå–éŸ³é¢‘æµURLå¤±è´¥: %w", err)
	}
	audiokeyAndUrls, err := runv3.Run(adamID, audiom3u8url, core.DeveloperToken, account.MediaUserToken, true)
	if err != nil {
		return "", "", fmt.Errorf("è·å–éŸ³é¢‘å¯†é’¥å’ŒURLå¤±è´¥: %w", err)
	}
	err = runv3.ExtMvDataWithDesc(audiokeyAndUrls, audPath, "  ğŸ”Š éŸ³é¢‘æµ")
	if err != nil {
		return "", "", fmt.Errorf("ä¸‹è½½æˆ–è§£å¯†è§†é¢‘æ•°æ®å¤±è´¥: %w", err)
	}

	tags := []string{
		"tool=",
		fmt.Sprintf("artist=%s", MVInfo.Data[0].Attributes.ArtistName),
		fmt.Sprintf("title=%s", MVInfo.Data[0].Attributes.Name),
		fmt.Sprintf("genre=%s", MVInfo.Data[0].Attributes.GenreNames[0]),
		fmt.Sprintf("created=%s", MVInfo.Data[0].Attributes.ReleaseDate),
		fmt.Sprintf("ISRC=%s", MVInfo.Data[0].Attributes.Isrc),
	}

	if MVInfo.Data[0].Attributes.ContentRating == "explicit" {
		tags = append(tags, "rating=1")
	} else if MVInfo.Data[0].Attributes.ContentRating == "clean" {
		tags = append(tags, "rating=2")
	} else {
		tags = append(tags, "rating=0")
	}

	if meta != nil {
		if meta.Data[0].Type == "playlists" && !core.Config.UseSongInfoForPlaylist {
			tags = append(tags, "disk=1/1", fmt.Sprintf("album=%s", meta.Data[0].Attributes.Name), fmt.Sprintf("track=%d", trackNum), fmt.Sprintf("tracknum=%d/%d", trackNum, trackTotal), fmt.Sprintf("album_artist=%s", meta.Data[0].Attributes.ArtistName), fmt.Sprintf("performer=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName), fmt.Sprintf("copyright=%s", meta.Data[0].Attributes.Copyright), fmt.Sprintf("UPC=%s", meta.Data[0].Attributes.Upc))
		} else {
			tags = append(tags, fmt.Sprintf("album=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.AlbumName), fmt.Sprintf("disk=%d/%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.DiscNumber, meta.Data[0].Relationships.Tracks.Data[trackTotal-1].Attributes.DiscNumber), fmt.Sprintf("track=%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber), fmt.Sprintf("tracknum=%d/%d", meta.Data[0].Relationships.Tracks.Data[index].Attributes.TrackNumber, meta.Data[0].Attributes.TrackCount), fmt.Sprintf("album_artist=%s", meta.Data[0].Attributes.ArtistName), fmt.Sprintf("performer=%s", meta.Data[0].Relationships.Tracks.Data[index].Attributes.ArtistName), fmt.Sprintf("copyright=%s", meta.Data[0].Attributes.Copyright), fmt.Sprintf("UPC=%s", meta.Data[0].Attributes.Upc))
		}
	} else {
		tags = append(tags, fmt.Sprintf("album=%s", MVInfo.Data[0].Attributes.AlbumName), fmt.Sprintf("disk=%d", MVInfo.Data[0].Attributes.DiscNumber), fmt.Sprintf("track=%d", MVInfo.Data[0].Attributes.TrackNumber), fmt.Sprintf("tracknum=%d", MVInfo.Data[0].Attributes.TrackNumber), fmt.Sprintf("performer=%s", MVInfo.Data[0].Attributes.ArtistName))
	}

	var covPath string
	if true {
		thumbURL := MVInfo.Data[0].Attributes.Artwork.URL
		baseThumbName := core.ForbiddenNames.ReplaceAllString(mvName, "_") + "_thumbnail"
		covPath, err = metadata.WriteCover(finalMvFolder, baseThumbName, thumbURL)
		if err == nil {
			tags = append(tags, fmt.Sprintf("cover=%s", covPath))
		}
	}

	tagsString := strings.Join(tags, ":")
	muxCmd := exec.Command("MP4Box", "-itags", tagsString, "-quiet", "-add", vidPath, "-add", audPath, "-keep-utc", "-new", mvOutPath)
	if err := muxCmd.Run(); err != nil {
		return "", "", err
	}
	defer os.Remove(vidPath)
	defer os.Remove(audPath)
	if covPath != "" {
		defer os.Remove(covPath)
	}
	return mvOutPath, resolution, nil
}
