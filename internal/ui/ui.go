package ui

import (
	"bufio"
	"fmt"
	"main/internal/logger"
	"main/utils/structs"
	"os"
	"strconv"
	"strings"
	"time"

	"main/internal/core"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
	"golang.org/x/term"
)

// UI暂停/恢复控制通道
var (
	suspendChan = make(chan struct{}, 1)
	resumeChan  = make(chan struct{}, 1)
	isSuspended = false
)

// Suspend 暂停UI更新（用于需要直接输出或交互的场景）
func Suspend() {
	select {
	case suspendChan <- struct{}{}:
		isSuspended = true
	default:
		// 已经在暂停状态，忽略
	}
}

// Resume 恢复UI更新
func Resume() {
	if isSuspended {
		select {
		case resumeChan <- struct{}{}:
			isSuspended = false
		default:
			// 已经在运行状态，忽略
		}
	}
}

// getTerminalWidth 获取终端宽度，如果获取失败则返回默认值
func getTerminalWidth() int {
	width, _, err := term.GetSize(int(os.Stdout.Fd()))
	if err != nil || width <= 0 {
		// 获取失败或无效，使用保守的默认值
		return 80
	}
	return width
}

func RenderUI(done <-chan struct{}) {
	// 增加刷新间隔到500ms，减少视觉噪音
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	// 首次更新标志：延迟初始化，避免预先打印换行符导致光标位置错误
	firstUpdate := true

	for {
		select {
		case <-done:
			return
		case <-suspendChan:
			// UI暂停，等待恢复信号
			<-resumeChan
		case <-ticker.C:
			PrintUI(firstUpdate)
			firstUpdate = false
		}
	}
}

func PrintUI(isFirstUpdate bool) {
	core.UiMutex.Lock()
	defer core.UiMutex.Unlock()

	if len(core.TrackStatuses) == 0 {
		return
	}

	var builder strings.Builder

	// 首次更新时打印占位换行符，后续更新时向上移动光标
	if isFirstUpdate {
		builder.WriteString(strings.Repeat("\n", len(core.TrackStatuses)))
	}

	// 向上移动N行（N = 曲目数）
	// 新的formatter保证每个track只占一行，不会换行
	builder.WriteString(fmt.Sprintf("\033[%dA", len(core.TrackStatuses)))

	// 获取终端宽度，用于智能格式化
	terminalWidth := getTerminalWidth()

	// 使用新的智能格式化系统
	for _, ts := range core.TrackStatuses {
		// 1. 格式化曲目行（自动适应终端宽度，保证不换行）
		line := FormatTrackLine(ts, terminalWidth)

		// 2. 应用颜色到状态部分（保持向后兼容）
		// 注意：新格式化器已经简化了状态，这里的颜色主要用于整行
		coloredLine := ts.StatusColor(line)

		// 3. 输出：清除当前行 + 打印新内容 + 换行
		builder.WriteString(fmt.Sprintf("\r\033[K%s\n", coloredLine))
	}

	fmt.Print(builder.String()) // OK: UI渲染核心，必须使用fmt.Print输出到stdout
}

func UpdateStatus(index int, status string, sColor func(a ...interface{}) string) {
	core.UiMutex.Lock()
	defer core.UiMutex.Unlock()
	if index < len(core.TrackStatuses) {
		now := time.Now().UnixNano()
		lastUpdate := core.TrackStatuses[index].LastUpdateNs

		// 防抖策略：除非是重要状态（完成、错误），否则限制最小更新间隔为100ms
		// 这减少了不必要的UI刷新，降低视觉噪音
		isImportantStatus := strings.Contains(status, "完成") ||
			strings.Contains(status, "错误") ||
			strings.Contains(status, "失败") ||
			strings.Contains(status, "✓") ||
			strings.Contains(status, "✗") ||
			strings.Contains(status, "跳过")

		minIntervalNs := int64(100 * time.Millisecond) // 100ms 最小间隔

		if !isImportantStatus && (now-lastUpdate) < minIntervalNs {
			// 跳过过于频繁的非重要更新
			return
		}

		core.TrackStatuses[index].Status = status
		core.TrackStatuses[index].StatusColor = sColor
		core.TrackStatuses[index].LastUpdateNs = now
	}
}

func SelectTracks(meta *structs.AutoGenerated, storefront, urlArg_i string) []int {
	trackTotal := len(meta.Data[0].Relationships.Tracks.Data)
	arr := make([]int, trackTotal)
	for i := 0; i < trackTotal; i++ {
		arr[i] = i + 1
	}
	selected := []int{}

	if core.Dl_song {
		found := false
		for i, track := range meta.Data[0].Relationships.Tracks.Data {
			if urlArg_i == track.ID {
				selected = append(selected, i+1)
				found = true
				break
			}
		}
		if !found {
			logger.Error("指定的单曲ID未在专辑中找到")
			return nil
		}
	} else if !core.Dl_select {
		selected = arr
	} else {
		var data [][]string
		for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {
			trackNum++
			var trackName string
			if meta.Data[0].Type == "albums" {
				trackName = fmt.Sprintf("%02d. %s", track.Attributes.TrackNumber, track.Attributes.Name)
			} else {
				trackName = fmt.Sprintf("%s - %s", track.Attributes.Name, track.Attributes.ArtistName)
			}
			data = append(data, []string{fmt.Sprint(trackNum),
				trackName,
				track.Attributes.ContentRating,
				track.Type})
		}
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"", "Track Name", "Rating", "Type"})
		table.SetRowLine(false)
		table.SetCaption(meta.Data[0].Type == "albums", fmt.Sprintf("Storefront: %s, %d tracks missing", strings.ToUpper(storefront), meta.Data[0].Attributes.TrackCount-trackTotal))
		table.SetHeaderColor(tablewriter.Colors{},
			tablewriter.Colors{tablewriter.FgRedColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold},
			tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.Bold})

		table.SetColumnColor(tablewriter.Colors{tablewriter.FgCyanColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgRedColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor},
			tablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})
		for _, row := range data {
			if row[2] == "explicit" {
				row[2] = "E"
			} else if row[2] == "clean" {
				row[2] = "C"
			} else {
				row[2] = "None"
			}
			if row[3] == "music-videos" {
				row[3] = "MV"
			} else if row[3] == "songs" {
				row[3] = "SONG"
			}
			table.Append(row)
		}
		table.Render()
		logger.Info("Please select from the track options above (multiple options separated by commas, ranges supported, or type 'all' to select all)")
		cyanColor := color.New(color.FgCyan)
		cyanColor.Print("select: ")
		reader := bufio.NewReader(os.Stdin)
		input, err := reader.ReadString('\n')
		if err != nil {
			logger.Error("读取输入错误: %v", err)
		}
		input = strings.TrimSpace(input)
		if input == "all" {
			selected = arr
		} else {
			selectedOptions := [][]string{}
			parts := strings.Split(input, ",")
			for _, part := range parts {
				if strings.Contains(part, "-") {
					rangeParts := strings.Split(part, "-")
					selectedOptions = append(selectedOptions, rangeParts)
				} else {
					selectedOptions = append(selectedOptions, []string{part})
				}
			}
			for _, opt := range selectedOptions {
				if len(opt) == 1 {
					num, err := strconv.Atoi(opt[0])
					if err != nil {
						continue
					}
					if num > 0 && num <= len(arr) {
						selected = append(selected, num)
					}
				} else if len(opt) == 2 {
					start, err1 := strconv.Atoi(opt[0])
					end, err2 := strconv.Atoi(opt[1])
					if err1 != nil || err2 != nil {
						continue
					}
					if start < 1 || end > len(arr) || start > end {
						continue
					}
					for i := start; i <= end; i++ {
						selected = append(selected, i)
					}
				}
			}
		}
	}
	return selected
}
