# ä»£ç æ”¹è¿›å®æ–½è®¡åˆ’

**åˆ†æ”¯**: `experimental/code-improvements`  
**åˆ›å»ºæ—¥æœŸ**: 2025-11-03  
**ç›®æ ‡**: é€æ­¥è½åœ°å®¡è®¡æŠ¥å‘Šä¸­çš„ 10 é¡¹æ ¸å¿ƒæ”¹è¿›å·¥ä½œ

---

## ğŸ“‹ æ€»è§ˆ

æœ¬è®¡åˆ’åŸºäºã€Šé¡¹ç›®å®¡è®¡æŠ¥å‘Š.mdã€‹ï¼Œèšç„¦äºé™¤å®‰å…¨æ€§å¤–çš„ 10 é¡¹æœ€é‡è¦æ”¹è¿›å·¥ä½œã€‚æ‰€æœ‰æ”¹è¿›éƒ½åœ¨å®éªŒæ€§åˆ†æ”¯ä¸­è¿›è¡Œï¼Œç¡®ä¿ä¸»åˆ†æ”¯çš„ç¨³å®šæ€§ã€‚

**é¢„è®¡æ€»å·¥æœŸ**: 4-6 å‘¨  
**å½“å‰çŠ¶æ€**: ğŸŸ¢ å‡†å¤‡é˜¶æ®µ

---

## ğŸ¯ æ”¹è¿›ä»»åŠ¡æ¸…å•

### é˜¶æ®µ 1: ç´§æ€¥ä¿®å¤ï¼ˆç¬¬1å‘¨ï¼‰

#### 1ï¸âƒ£ ä¿®å¤å¾ªç¯ä¸­çš„èµ„æºæ³„æ¼é—®é¢˜ ğŸ”´

**ä¼˜å…ˆçº§**: ç´§æ€¥  
**å½±å“**: é«˜ | **éš¾åº¦**: ä¸­ | **é¢„è®¡æ—¶é—´**: 2-3å¤©

**é—®é¢˜å®šä½**:
- æ–‡ä»¶: `internal/api/client.go`
- å‡½æ•°: `CheckArtist` (ç¬¬74-195è¡Œ)
- é—®é¢˜: åœ¨ for å¾ªç¯ä¸­ä½¿ç”¨ `defer do.Body.Close()`ï¼Œå¯¼è‡´ HTTP è¿æ¥æœªåŠæ—¶é‡Šæ”¾

**å®æ–½æ­¥éª¤**:
```bash
# 1. åˆ›å»ºå­ä»»åŠ¡åˆ†æ”¯
git checkout -b fix/resource-leak-in-loop

# 2. ä¿®æ”¹æ–‡ä»¶
# ç¼–è¾‘ internal/api/client.go

# 3. æµ‹è¯•éªŒè¯
# - ä¸‹è½½åŒ…å«å¤§é‡ä¸“è¾‘çš„è‰ºæœ¯å®¶ä½œå“
# - ç›‘æ§å†…å­˜å’Œæ–‡ä»¶æè¿°ç¬¦ä½¿ç”¨æƒ…å†µ
# - éªŒè¯æ˜¯å¦è¿˜æœ‰èµ„æºæ³„æ¼

# 4. æäº¤ä¿®æ”¹
git add internal/api/client.go
git commit -m "fix: ä¿®å¤å¾ªç¯ä¸­çš„HTTPè¿æ¥èµ„æºæ³„æ¼

- å°† defer do.Body.Close() ç§»åˆ°åŒ¿åå‡½æ•°å†…ç«‹å³æ‰§è¡Œ
- é¿å…åœ¨é•¿å¾ªç¯ä¸­ç´¯ç§¯å¤§é‡æœªå…³é—­çš„è¿æ¥
- æå‡å¤§é‡ä¸“è¾‘ä¸‹è½½æ—¶çš„ç¨³å®šæ€§"

# 5. åˆå¹¶åˆ°å®éªŒåˆ†æ”¯
git checkout experimental/code-improvements
git merge fix/resource-leak-in-loop
```

**ä¿®æ”¹ç¤ºä¾‹**:
```go
// ä¿®æ”¹å‰ (æœ‰é—®é¢˜):
for {
    do, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer do.Body.Close()  // âš ï¸ é—®é¢˜ï¼šå¾ªç¯ç»“æŸå‰ä¸ä¼šæ‰§è¡Œ
    // ... å¤„ç†å“åº”
}

// ä¿®æ”¹å (æ­£ç¡®):
for {
    do, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    
    // ä½¿ç”¨é—­åŒ…ç«‹å³å…³é—­
    err = func() error {
        defer do.Body.Close()
        obj := new(structs.AutoGeneratedArtist)
        if err := json.NewDecoder(do.Body).Decode(&obj); err != nil {
            return err
        }
        // ... å¤„ç†æ•°æ®
        return nil
    }()
    
    if err != nil {
        return nil, err
    }
}
```

**éªŒè¯æ¸…å•**:
- [ ] ä»£ç å®¡æŸ¥é€šè¿‡
- [ ] èµ„æºæ³„æ¼æµ‹è¯•é€šè¿‡ï¼ˆç›‘æ§å†…å­˜å’Œæ–‡ä»¶æè¿°ç¬¦ï¼‰
- [ ] åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼ˆä¸‹è½½è‰ºæœ¯å®¶å…¨éƒ¨ä½œå“ï¼‰
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡ï¼ˆå¯¹æ¯”ä¿®æ”¹å‰åçš„å†…å­˜å ç”¨ï¼‰

---

#### 2ï¸âƒ£ æ·»åŠ  Context å–æ¶ˆæœºåˆ¶ ğŸ”´

**ä¼˜å…ˆçº§**: ç´§æ€¥  
**å½±å“**: é«˜ | **éš¾åº¦**: ä¸­ | **é¢„è®¡æ—¶é—´**: 3-4å¤©

**é—®é¢˜å®šä½**:
- ä¸»è¦æ–‡ä»¶: `main.go`, `internal/downloader/downloader.go`
- é—®é¢˜: é•¿æ—¶é—´ä»»åŠ¡æ— æ³•ä¼˜é›…å–æ¶ˆï¼ŒCtrl+C å¯èƒ½å¯¼è‡´æ–‡ä»¶æŸåæˆ–ç¼“å­˜æ®‹ç•™

**å®æ–½æ­¥éª¤**:
```bash
# 1. åˆ›å»ºå­ä»»åŠ¡åˆ†æ”¯
git checkout -b feature/context-cancellation

# 2. ä¿®æ”¹æ–‡ä»¶ï¼ˆæŒ‰é¡ºåºï¼‰
# - main.go: åˆ›å»ºå¯å–æ¶ˆçš„ context
# - internal/downloader/downloader.go: åœ¨ Rip å‡½æ•°ä¸­æ·»åŠ  context
# - internal/api/client.go: åœ¨ HTTP è¯·æ±‚ä¸­ä½¿ç”¨ context
# - utils/runv3/runv3.go: æ›¿æ¢ context.TODO()
# - utils/runv14/runv14.go: æ›¿æ¢ context.TODO()

# 3. æµ‹è¯•éªŒè¯
# - å¯åŠ¨æ‰¹é‡ä¸‹è½½
# - æŒ‰ Ctrl+C ä¸­æ–­
# - éªŒè¯æ˜¯å¦ä¼˜é›…é€€å‡º
# - æ£€æŸ¥ç¼“å­˜æ˜¯å¦æ­£ç¡®æ¸…ç†

# 4. æäº¤ä¿®æ”¹
git add .
git commit -m "feat: æ·»åŠ  Context å–æ¶ˆæœºåˆ¶æ”¯æŒä¼˜é›…é€€å‡º

- åœ¨ main.go ä¸­åˆ›å»ºå¯å–æ¶ˆçš„ context
- æ‰€æœ‰é•¿æ—¶é—´ä»»åŠ¡æ”¯æŒ context å–æ¶ˆ
- ä¿¡å·å¤„ç†æ”¹è¿›ï¼Œæ”¯æŒä¼˜é›…é€€å‡º
- æ›¿æ¢æ‰€æœ‰ context.TODO() ä¸ºå®é™… context
- ç¡®ä¿ä¸­æ–­æ—¶æ­£ç¡®æ¸…ç†ç¼“å­˜å’Œä¸´æ—¶æ–‡ä»¶"
```

**ä¿®æ”¹è¦ç‚¹**:

1. **main.go** - åˆ›å»º context:
```go
func main() {
    // åˆ›å»ºå¯å–æ¶ˆçš„ context
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // æ”¹è¿›ä¿¡å·å¤„ç†
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)
    go func() {
        <-sigChan
        logger.Warn("æ”¶åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨å®‰å…¨é€€å‡º...")
        cancel() // å–æ¶ˆæ‰€æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
        
        // ç­‰å¾…æ¸…ç†å®Œæˆ
        time.Sleep(2 * time.Second)
        logger.Info("æ¸…ç†å®Œæˆï¼Œé€€å‡º")
        os.Exit(0)
    }()
    
    // ä¼ é€’ context åˆ°ä¸‹è½½å‡½æ•°
    runDownloads(ctx, urls, isBatch, taskFile, progressNotifier)
}
```

2. **downloader.go** - æ·»åŠ  context å‚æ•°:
```go
func Rip(ctx context.Context, albumId, storefront string, ...) error {
    // æ£€æŸ¥ context æ˜¯å¦å·²å–æ¶ˆ
    select {
    case <-ctx.Done():
        return fmt.Errorf("ä»»åŠ¡å·²å–æ¶ˆ: %w", ctx.Err())
    default:
    }
    
    // åœ¨å…³é”®ç‚¹æ£€æŸ¥å–æ¶ˆçŠ¶æ€
    for i, track := range tracks {
        select {
        case <-ctx.Done():
            logger.Info("ä¸‹è½½å·²å–æ¶ˆï¼Œæ­£åœ¨æ¸…ç†...")
            return ctx.Err()
        default:
        }
        
        // ä¸‹è½½é€»è¾‘...
    }
    
    return nil
}
```

3. **HTTP è¯·æ±‚** - ä½¿ç”¨ context:
```go
// ä¹‹å‰
req, err := http.NewRequest("GET", url, nil)

// ä¹‹å
req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
```

**éªŒè¯æ¸…å•**:
- [ ] ä»£ç ç¼–è¯‘é€šè¿‡
- [ ] å•ä¸ªä¸‹è½½å¯ä»¥ä¸­æ–­
- [ ] æ‰¹é‡ä¸‹è½½å¯ä»¥ä¸­æ–­
- [ ] ä¸­æ–­åç¼“å­˜æ­£ç¡®æ¸…ç†
- [ ] ä¸­æ–­åæ²¡æœ‰é—ç•™çš„ä¸´æ—¶æ–‡ä»¶
- [ ] æ—¥å¿—æ­£ç¡®æ˜¾ç¤ºå–æ¶ˆä¿¡æ¯

---

### é˜¶æ®µ 2: é‡è¦åŠŸèƒ½ä¿®å¤ï¼ˆç¬¬2å‘¨ï¼‰

#### 3ï¸âƒ£ è§£å†³è™šæ‹ŸSinglesä¸“è¾‘çš„åˆä½œè‰ºæœ¯å®¶å¤„ç† ğŸŸ¡

**ä¼˜å…ˆçº§**: é‡è¦  
**å½±å“**: ä¸­ | **éš¾åº¦**: ä¸­ | **é¢„è®¡æ—¶é—´**: 2-3å¤©

**é—®é¢˜æè¿°**:
- ä¸å…¶ä»–è‰ºæœ¯å®¶åˆä½œçš„å•æ›²æœªèƒ½çº³å…¥è™šæ‹ŸSinglesä¸“è¾‘
- å½“å‰è‰ºæœ¯å®¶ä½œä¸ºæ¬¡è¦è‰ºæœ¯å®¶æ—¶çš„å•æ›²ä¹Ÿåº”è¢«çº³å…¥

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b fix/collab-singles-handling
```

**ä¿®æ”¹å†…å®¹**:

1. **å¢å¼ºå•æ›²è¯†åˆ«é€»è¾‘** (`core/state.go`):
```go
// IsSingleAlbum åˆ¤æ–­ä¸“è¾‘æ˜¯å¦ä¸ºå•æ›²ä¸“è¾‘ï¼ˆå¢å¼ºç‰ˆï¼‰
func IsSingleAlbum(meta *structs.AutoGenerated, targetArtist string) bool {
    if !Config.EnableVirtualSingles {
        return false
    }
    
    // è·³è¿‡æ’­æ”¾åˆ—è¡¨
    if strings.Contains(meta.Data[0].ID, "pl.") {
        return false
    }
    
    // 1. æ£€æŸ¥ IsSingle å­—æ®µ
    if meta.Data[0].Attributes.IsSingle {
        return true
    }
    
    // 2. æ£€æŸ¥ä¸“è¾‘åç§°
    albumName := meta.Data[0].Attributes.Name
    if strings.Contains(albumName, "- Single") ||
        strings.Contains(albumName, " Single") ||
        strings.Contains(albumName, "å•æ›²") {
        return true
    }
    
    // 3. æ£€æŸ¥æ›²ç›®æ•°é‡
    trackCount := meta.Data[0].Attributes.TrackCount
    if trackCount > 0 && trackCount <= 3 {
        // 4. æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºç›®æ ‡è‰ºæœ¯å®¶çš„åˆä½œå•æ›²
        if targetArtist != "" && isCollaborationSingle(meta, targetArtist) {
            return true
        }
        return true
    }
    
    return false
}

// æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºåˆä½œå•æ›²
func isCollaborationSingle(meta *structs.AutoGenerated, targetArtist string) bool {
    albumArtist := meta.Data[0].Attributes.ArtistName
    
    // æ£€æŸ¥ä¸“è¾‘è‰ºæœ¯å®¶åç§°æ˜¯å¦åŒ…å«ç›®æ ‡è‰ºæœ¯å®¶
    if containsArtist(albumArtist, targetArtist) {
        return true
    }
    
    // æ£€æŸ¥æ›²ç›®è‰ºæœ¯å®¶
    if len(meta.Data[0].Relationships.Tracks.Data) > 0 {
        for _, track := range meta.Data[0].Relationships.Tracks.Data {
            trackArtist := track.Attributes.ArtistName
            if containsArtist(trackArtist, targetArtist) {
                return true
            }
        }
    }
    
    return false
}

// æ–°å¢ï¼šæ£€æŸ¥è‰ºæœ¯å®¶åç§°æ˜¯å¦åŒ…å«ç›®æ ‡è‰ºæœ¯å®¶
func containsArtist(fullName, targetArtist string) bool {
    artists := splitArtists(fullName)
    for _, artist := range artists {
        if strings.EqualFold(strings.TrimSpace(artist), targetArtist) {
            return true
        }
    }
    return false
}

// æ–°å¢ï¼šåˆ†å‰²è‰ºæœ¯å®¶åç§°
func splitArtists(fullName string) []string {
    separators := []string{" & ", " ft. ", " feat. ", " featuring ", ", "}
    
    artists := []string{fullName}
    for _, sep := range separators {
        var newArtists []string
        for _, artist := range artists {
            parts := strings.Split(artist, sep)
            newArtists = append(newArtists, parts...)
        }
        artists = newArtists
    }
    
    return artists
}
```

2. **ä¿®æ”¹è°ƒç”¨å¤„** (`internal/downloader/downloader.go`):
```go
// åœ¨åˆ¤æ–­æ˜¯å¦ä¸ºå•æ›²æ—¶ä¼ å…¥ç›®æ ‡è‰ºæœ¯å®¶
isSingle := core.IsSingleAlbum(meta, urlArtistName)
```

**æµ‹è¯•åœºæ™¯**:
1. ä¸‹è½½ "Taylor Swift & Ed Sheeran - Everything Has Changed"
2. ä¸‹è½½ "Olivia Rodrigo & Joshua Bassett - I Think I Kinda, You Know"
3. éªŒè¯è¿™äº›åˆä½œå•æ›²æ˜¯å¦æ­£ç¡®å½’å…¥ Singles è™šæ‹Ÿä¸“è¾‘

**éªŒè¯æ¸…å•**:
- [ ] ä¸»è‰ºæœ¯å®¶çš„åˆä½œå•æ›²è¢«æ­£ç¡®è¯†åˆ«
- [ ] æ¬¡è¦è‰ºæœ¯å®¶çš„å•æ›²ä¹Ÿèƒ½è¢«è¯†åˆ«
- [ ] éå•æ›²ä¸“è¾‘ä¸ä¼šè¢«è¯¯åˆ¤
- [ ] è™šæ‹ŸSinglesä¸“è¾‘æ›²ç›®ç¼–å·æ­£ç¡®
- [ ] åŸæœ‰åŠŸèƒ½ä¸å—å½±å“

---

#### 4ï¸âƒ£ éªŒè¯å¹¶ä¿®å¤å·¥ä½œ-ä¼‘æ¯å¾ªç¯åŠŸèƒ½ ğŸŸ¡

**ä¼˜å…ˆçº§**: é‡è¦  
**å½±å“**: ä¸­ | **éš¾åº¦**: ä½ | **é¢„è®¡æ—¶é—´**: 1å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b fix/work-rest-cycle
```

**è¯Šæ–­æ–¹æ¡ˆ**:

1. **æ·»åŠ è°ƒè¯•æ—¥å¿—** (`main.go`):
```go
// åœ¨å·¥ä½œ-ä¼‘æ¯å¾ªç¯æ£€æŸ¥å¤„æ·»åŠ 
if isBatch && core.Config.WorkRestEnabled {
    logger.Debug("å·¥ä½œ-ä¼‘æ¯å¾ªç¯é…ç½®: enabled=%v, work=%dåˆ†é’Ÿ, rest=%dåˆ†é’Ÿ", 
        core.Config.WorkRestEnabled, 
        core.Config.WorkDurationMinutes, 
        core.Config.RestDurationMinutes)
    
    workStartTime = time.Now()
    logger.Debug("å·¥ä½œå¼€å§‹æ—¶é—´: %s", workStartTime.Format("15:04:05"))
}

// åœ¨æ£€æŸ¥ç‚¹æ·»åŠ 
if isBatch && core.Config.WorkRestEnabled && i < len(finalUrls)-1 {
    elapsed := time.Since(workStartTime)
    workDuration := time.Duration(core.Config.WorkDurationMinutes) * time.Minute
    
    logger.Debug("å·¥ä½œæ—¶é•¿æ£€æŸ¥: å·²å·¥ä½œ %.1f åˆ†é’Ÿ / é˜ˆå€¼ %d åˆ†é’Ÿ", 
        elapsed.Minutes(), 
        core.Config.WorkDurationMinutes)
    
    if elapsed >= workDuration {
        logger.Info("è§¦å‘å·¥ä½œ-ä¼‘æ¯å¾ªç¯...")
        // ... ä¼‘æ¯é€»è¾‘
    }
}
```

2. **åˆ›å»ºæµ‹è¯•é…ç½®**:
```yaml
# config-test-workrest.yaml
work-rest-enabled: true
work-duration-minutes: 1  # 1åˆ†é’Ÿç”¨äºå¿«é€Ÿæµ‹è¯•
rest-duration-minutes: 1
```

3. **åˆ›å»ºæµ‹è¯•é“¾æ¥æ–‡ä»¶**:
```bash
# test-urls.txt - åŒ…å«5ä¸ªæµ‹è¯•é“¾æ¥
https://music.apple.com/cn/album/1
https://music.apple.com/cn/album/2
https://music.apple.com/cn/album/3
https://music.apple.com/cn/album/4
https://music.apple.com/cn/album/5
```

4. **è¿è¡Œæµ‹è¯•**:
```bash
./apple-music-downloader --config config-test-workrest.yaml test-urls.txt
# è§‚å¯Ÿæ˜¯å¦åœ¨1åˆ†é’Ÿåè¿›å…¥ä¼‘æ¯
```

**å¯èƒ½çš„ä¿®å¤ç‚¹**:
- æ£€æŸ¥ `isBatch` åˆ¤æ–­é€»è¾‘æ˜¯å¦æ­£ç¡®
- éªŒè¯æ—¶é—´è®¡ç®—æ˜¯å¦å‡†ç¡®
- ç¡®è®¤é…ç½®åŠ è½½æ˜¯å¦æˆåŠŸ

**éªŒè¯æ¸…å•**:
- [ ] é…ç½®æ­£ç¡®åŠ è½½
- [ ] å·¥ä½œæ—¶é•¿è®¡ç®—å‡†ç¡®
- [ ] ä¼‘æ¯å€’è®¡æ—¶æ­£å¸¸æ˜¾ç¤º
- [ ] ä¼‘æ¯ç»“æŸåæ­£ç¡®æ¢å¤
- [ ] æ—¥å¿—è¾“å‡ºæ¸…æ™°æ˜“æ‡‚

---

### é˜¶æ®µ 3: è´¨é‡æå‡ï¼ˆç¬¬3å‘¨ï¼‰

#### 5ï¸âƒ£ å¢å¼ºé…ç½®éªŒè¯æœºåˆ¶ ğŸŸ¡

**ä¼˜å…ˆçº§**: é‡è¦  
**å½±å“**: ä¸­ | **éš¾åº¦**: ä½ | **é¢„è®¡æ—¶é—´**: 2å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b feature/config-validation
```

**å®ç°æ–¹æ¡ˆ**:

1. **åˆ›å»ºé…ç½®éªŒè¯æ¨¡å—** (`internal/config/validator.go`):
```go
package config

import (
    "fmt"
    "os"
    "path/filepath"
    "main/utils/structs"
)

// ValidationError é…ç½®éªŒè¯é”™è¯¯
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Field, e.Message)
}

// ValidateConfig éªŒè¯é…ç½®çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§
func ValidateConfig(cfg *structs.ConfigSet) []error {
    var errors []error
    
    // 1. è´¦å·éªŒè¯
    errors = append(errors, validateAccounts(cfg.Accounts)...)
    
    // 2. è·¯å¾„éªŒè¯
    errors = append(errors, validatePaths(cfg)...)
    
    // 3. æ•°å€¼èŒƒå›´éªŒè¯
    errors = append(errors, validateNumericValues(cfg)...)
    
    // 4. éŸ³è´¨å‚æ•°éªŒè¯
    errors = append(errors, validateQualitySettings(cfg)...)
    
    return errors
}

// éªŒè¯è´¦å·é…ç½®
func validateAccounts(accounts []structs.Account) []error {
    var errors []error
    
    if len(accounts) == 0 {
        errors = append(errors, ValidationError{
            Field:   "accounts",
            Message: "è‡³å°‘éœ€è¦é…ç½®ä¸€ä¸ªè´¦å·",
        })
        return errors
    }
    
    for i, acc := range accounts {
        prefix := fmt.Sprintf("accounts[%d]", i)
        
        if acc.Storefront == "" {
            errors = append(errors, ValidationError{
                Field:   prefix + ".storefront",
                Message: "storefront ä¸èƒ½ä¸ºç©º",
            })
        }
        
        if acc.MediaUserToken == "" {
            errors = append(errors, ValidationError{
                Field:   prefix + ".media-user-token",
                Message: "media-user-token ä¸èƒ½ä¸ºç©º",
            })
        }
        
        // éªŒè¯ç«¯å£æ ¼å¼
        if acc.DecryptM3u8Port == "" || acc.GetM3u8Port == "" {
            errors = append(errors, ValidationError{
                Field:   prefix + ".ports",
                Message: "ç«¯å£é…ç½®ä¸èƒ½ä¸ºç©º",
            })
        }
    }
    
    return errors
}

// éªŒè¯è·¯å¾„é…ç½®
func validatePaths(cfg *structs.ConfigSet) []error {
    var errors []error
    
    paths := map[string]string{
        "alac-save-folder":  cfg.AlacSaveFolder,
        "atmos-save-folder": cfg.AtmosSaveFolder,
        "mv-save-folder":    cfg.MVSaveFolder,
    }
    
    for name, path := range paths {
        if path == "" {
            errors = append(errors, ValidationError{
                Field:   name,
                Message: "è·¯å¾„ä¸èƒ½ä¸ºç©º",
            })
            continue
        }
        
        // éªŒè¯è·¯å¾„æ˜¯å¦å¯å†™
        dir := filepath.Dir(path)
        if _, err := os.Stat(dir); os.IsNotExist(err) {
            errors = append(errors, ValidationError{
                Field:   name,
                Message: fmt.Sprintf("çˆ¶ç›®å½•ä¸å­˜åœ¨: %s", dir),
            })
        }
    }
    
    return errors
}

// éªŒè¯æ•°å€¼èŒƒå›´
func validateNumericValues(cfg *structs.ConfigSet) []error {
    var errors []error
    
    // çº¿ç¨‹æ•°éªŒè¯
    threadConfigs := map[string]int{
        "chunk_downloadthreads":    cfg.ChunkDownloadThreads,
        "aac_downloadthreads":      cfg.AacDownloadThreads,
        "lossless_downloadthreads": cfg.LosslessDownloadThreads,
        "hires_downloadthreads":    cfg.HiresDownloadThreads,
    }
    
    for name, value := range threadConfigs {
        if value < 1 || value > 100 {
            errors = append(errors, ValidationError{
                Field:   name,
                Message: fmt.Sprintf("çº¿ç¨‹æ•°è¶…å‡ºåˆç†èŒƒå›´ (1-100): %d", value),
            })
        }
    }
    
    // ç¼“å†²åŒºéªŒè¯
    if cfg.BufferSizeKB < 1 || cfg.BufferSizeKB > 10240 {
        errors = append(errors, ValidationError{
            Field:   "BufferSizeKB",
            Message: fmt.Sprintf("ç¼“å†²åŒºå¤§å°è¶…å‡ºåˆç†èŒƒå›´ (1-10240): %d", cfg.BufferSizeKB),
        })
    }
    
    // å·¥ä½œ-ä¼‘æ¯å¾ªç¯éªŒè¯
    if cfg.WorkRestEnabled {
        if cfg.WorkDurationMinutes < 1 {
            errors = append(errors, ValidationError{
                Field:   "work-duration-minutes",
                Message: "å·¥ä½œæ—¶é•¿å¿…é¡»å¤§äº 0",
            })
        }
        if cfg.RestDurationMinutes < 1 {
            errors = append(errors, ValidationError{
                Field:   "rest-duration-minutes",
                Message: "ä¼‘æ¯æ—¶é•¿å¿…é¡»å¤§äº 0",
            })
        }
    }
    
    return errors
}

// éªŒè¯éŸ³è´¨å‚æ•°
func validateQualitySettings(cfg *structs.ConfigSet) []error {
    var errors []error
    
    // ALAC é‡‡æ ·ç‡éªŒè¯
    validAlacRates := []int{0, 44100, 48000, 96000, 192000}
    if !contains(validAlacRates, cfg.AlacMax) {
        errors = append(errors, ValidationError{
            Field:   "alac-max",
            Message: fmt.Sprintf("æ— æ•ˆçš„ ALAC é‡‡æ ·ç‡: %d (æœ‰æ•ˆå€¼: 44100, 48000, 96000, 192000)", cfg.AlacMax),
        })
    }
    
    // Atmos ç ç‡éªŒè¯
    validAtmosRates := []int{0, 2448, 2768}
    if !contains(validAtmosRates, cfg.AtmosMax) {
        errors = append(errors, ValidationError{
            Field:   "atmos-max",
            Message: fmt.Sprintf("æ— æ•ˆçš„ Atmos ç ç‡: %d (æœ‰æ•ˆå€¼: 2448, 2768)", cfg.AtmosMax),
        })
    }
    
    // AAC ç±»å‹éªŒè¯
    validAacTypes := []string{"aac-lc", "aac", "aac-binaural", "aac-downmix"}
    if !containsStr(validAacTypes, cfg.AacType) {
        errors = append(errors, ValidationError{
            Field:   "aac-type",
            Message: fmt.Sprintf("æ— æ•ˆçš„ AAC ç±»å‹: %s", cfg.AacType),
        })
    }
    
    return errors
}

func contains(slice []int, value int) bool {
    for _, v := range slice {
        if v == value {
            return true
        }
    }
    return false
}

func containsStr(slice []string, value string) bool {
    for _, v := range slice {
        if v == value {
            return true
        }
    }
    return false
}
```

2. **åœ¨ LoadConfig åè°ƒç”¨éªŒè¯** (`core/state.go`):
```go
import "main/internal/config"

func LoadConfig(configPath string) error {
    // ... ç°æœ‰çš„åŠ è½½é€»è¾‘
    
    // éªŒè¯é…ç½®
    if errs := config.ValidateConfig(&Config); len(errs) > 0 {
        logger.Error("é…ç½®éªŒè¯å¤±è´¥ï¼Œå‘ç° %d ä¸ªé”™è¯¯:", len(errs))
        for i, err := range errs {
            logger.Error("  %d. %v", i+1, err)
        }
        return fmt.Errorf("é…ç½®éªŒè¯å¤±è´¥")
    }
    
    logger.Info("âœ… é…ç½®éªŒè¯é€šè¿‡")
    return nil
}
```

**éªŒè¯æ¸…å•**:
- [ ] æ‰€æœ‰éªŒè¯è§„åˆ™æ­£ç¡®å®ç°
- [ ] é”™è¯¯ä¿¡æ¯æ¸…æ™°æ˜“æ‡‚
- [ ] ä¸å½±å“æ­£å¸¸é…ç½®çš„åŠ è½½
- [ ] èƒ½å¤Ÿæ•è·æ‰€æœ‰å·²çŸ¥çš„é…ç½®é”™è¯¯
- [ ] æ·»åŠ äº†ç›¸åº”çš„å•å…ƒæµ‹è¯•

---

#### 6ï¸âƒ£ ä¼˜åŒ–å¹¶å‘é”ä½¿ç”¨ï¼ˆRWMutexï¼‰ğŸŸ¢

**ä¼˜å…ˆçº§**: æ€§èƒ½ä¼˜åŒ–  
**å½±å“**: ä¸­ | **éš¾åº¦**: ä½ | **é¢„è®¡æ—¶é—´**: 1å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b perf/rwmutex-optimization
```

**ä¿®æ”¹å†…å®¹** (`core/state.go`):
```go
var (
    // æ”¹ä¸º RWMutex
    virtualSinglesTrackNumbers = make(map[string]int)
    virtualSinglesLock         sync.RWMutex  // ä¹‹å‰æ˜¯ sync.Mutex
    
    trackEffectiveNumbers = make(map[string]int)
    trackEffectiveLock    sync.RWMutex  // ä¹‹å‰æ˜¯ sync.Mutex
)

// GetVirtualSinglesTrackNumber ä¼˜åŒ–ç‰ˆæœ¬
func GetVirtualSinglesTrackNumber(artistName string) int {
    // å…ˆç”¨è¯»é”æ£€æŸ¥
    virtualSinglesLock.RLock()
    if num, exists := virtualSinglesTrackNumbers[artistName]; exists {
        next := num
        virtualSinglesLock.RUnlock()
        
        // å‡çº§ä¸ºå†™é”æ›´æ–°
        virtualSinglesLock.Lock()
        virtualSinglesTrackNumbers[artistName]++
        virtualSinglesLock.Unlock()
        
        return next
    }
    virtualSinglesLock.RUnlock()
    
    // ä¸å­˜åœ¨åˆ™ç”¨å†™é”åˆå§‹åŒ–
    virtualSinglesLock.Lock()
    defer virtualSinglesLock.Unlock()
    
    // åŒé‡æ£€æŸ¥ï¼ˆé¿å…ç«æ€ï¼‰
    if _, exists := virtualSinglesTrackNumbers[artistName]; !exists {
        virtualSinglesTrackNumbers[artistName] = 1
    }
    
    trackNum := virtualSinglesTrackNumbers[artistName]
    virtualSinglesTrackNumbers[artistName]++
    
    return trackNum
}

// GetTrackEffectiveNumber ä¼˜åŒ–ç‰ˆæœ¬ï¼ˆåªè¯»æ“ä½œï¼‰
func GetTrackEffectiveNumber(trackID string) int {
    trackEffectiveLock.RLock()
    defer trackEffectiveLock.RUnlock()
    
    if num, exists := trackEffectiveNumbers[trackID]; exists {
        return num
    }
    return -1
}

// SetTrackEffectiveNumber å†™æ“ä½œä¿æŒ Lock
func SetTrackEffectiveNumber(trackID string, effectiveNum int) {
    trackEffectiveLock.Lock()
    defer trackEffectiveLock.Unlock()
    trackEffectiveNumbers[trackID] = effectiveNum
}
```

**æ€§èƒ½æµ‹è¯•**:
```bash
# è¿è¡ŒåŸºå‡†æµ‹è¯•
go test -bench=. -benchmem ./internal/core/

# å¯¹æ¯”ä¼˜åŒ–å‰åçš„æ€§èƒ½æ•°æ®
```

**éªŒè¯æ¸…å•**:
- [ ] ç¼–è¯‘é€šè¿‡ï¼Œæ— ç«æ€æ¡ä»¶
- [ ] åŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] åŸºå‡†æµ‹è¯•æ˜¾ç¤ºæ€§èƒ½æå‡
- [ ] å¹¶å‘æµ‹è¯•æ— æ­»é”

---

#### 7ï¸âƒ£ æ·»åŠ æ ¸å¿ƒåŠŸèƒ½çš„å•å…ƒæµ‹è¯• ğŸŸ¢

**ä¼˜å…ˆçº§**: è´¨é‡æå‡  
**å½±å“**: é«˜ | **éš¾åº¦**: ä¸­ | **é¢„è®¡æ—¶é—´**: 5-7å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b test/add-unit-tests
```

**æµ‹è¯•è®¡åˆ’**:

1. **æ ¸å¿ƒé€»è¾‘æµ‹è¯•** (`internal/core/state_test.go`):
```go
package core

import (
    "testing"
    "main/utils/structs"
)

func TestIsSingleAlbum(t *testing.T) {
    tests := []struct {
        name     string
        meta     *structs.AutoGenerated
        artist   string
        expected bool
    }{
        {
            name: "æ ‡å‡†å•æ›²ï¼ˆIsSingleä¸ºtrueï¼‰",
            meta: &structs.AutoGenerated{
                Data: []structs.AlbumData{{
                    Attributes: structs.AlbumAttributes{
                        IsSingle: true,
                    },
                }},
            },
            expected: true,
        },
        {
            name: "ä¸“è¾‘åç§°åŒ…å« - Single",
            meta: &structs.AutoGenerated{
                Data: []structs.AlbumData{{
                    Attributes: structs.AlbumAttributes{
                        Name: "Beautiful Things - Single",
                    },
                }},
            },
            expected: true,
        },
        {
            name: "å°‘äº3é¦–æ›²ç›®çš„ä¸“è¾‘",
            meta: &structs.AutoGenerated{
                Data: []structs.AlbumData{{
                    Attributes: structs.AlbumAttributes{
                        TrackCount: 2,
                    },
                }},
            },
            expected: true,
        },
        {
            name: "æ­£å¸¸ä¸“è¾‘ï¼ˆéå•æ›²ï¼‰",
            meta: &structs.AutoGenerated{
                Data: []structs.AlbumData{{
                    Attributes: structs.AlbumAttributes{
                        Name:       "The Tortured Poets Department",
                        TrackCount: 16,
                        IsSingle:   false,
                    },
                }},
            },
            expected: false,
        },
    }
    
    // å¯ç”¨è™šæ‹ŸSinglesåŠŸèƒ½
    Config.EnableVirtualSingles = true
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := IsSingleAlbum(tt.meta, tt.artist)
            if result != tt.expected {
                t.Errorf("IsSingleAlbum() = %v, æœŸæœ› %v", result, tt.expected)
            }
        })
    }
}

func TestGetPrimaryArtist(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
    }{
        {"å•ä¸€è‰ºæœ¯å®¶", "Taylor Swift", "Taylor Swift"},
        {"&åˆ†éš”", "Taylor Swift & Ed Sheeran", "Taylor Swift"},
        {"ft.åˆ†éš”", "Olivia Rodrigo ft. Joshua Bassett", "Olivia Rodrigo"},
        {"feat.åˆ†éš”", "Ariana Grande feat. The Weeknd", "Ariana Grande"},
        {"featuringåˆ†éš”", "Lady Gaga featuring Bradley Cooper", "Lady Gaga"},
        {"æ··åˆå¤§å°å†™", "Billie Eilish FT. Khalid", "Billie Eilish"},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := GetPrimaryArtist(tt.input)
            if result != tt.expected {
                t.Errorf("GetPrimaryArtist(%q) = %q, æœŸæœ› %q", 
                    tt.input, result, tt.expected)
            }
        })
    }
}

func TestVirtualSinglesTrackNumber(t *testing.T) {
    // é‡ç½®çŠ¶æ€
    virtualSinglesTrackNumbers = make(map[string]int)
    
    artist1 := "Taylor Swift"
    artist2 := "Ed Sheeran"
    
    // æµ‹è¯•ç¬¬ä¸€ä¸ªè‰ºæœ¯å®¶
    if num := GetVirtualSinglesTrackNumber(artist1); num != 1 {
        t.Errorf("ç¬¬ä¸€é¦–å•æ›²åº”è¯¥æ˜¯ç¼–å· 1, å¾—åˆ° %d", num)
    }
    if num := GetVirtualSinglesTrackNumber(artist1); num != 2 {
        t.Errorf("ç¬¬äºŒé¦–å•æ›²åº”è¯¥æ˜¯ç¼–å· 2, å¾—åˆ° %d", num)
    }
    
    // æµ‹è¯•ç¬¬äºŒä¸ªè‰ºæœ¯å®¶ï¼ˆç‹¬ç«‹è®¡æ•°ï¼‰
    if num := GetVirtualSinglesTrackNumber(artist2); num != 1 {
        t.Errorf("ä¸åŒè‰ºæœ¯å®¶åº”è¯¥ç‹¬ç«‹è®¡æ•°, å¾—åˆ° %d", num)
    }
    
    // ç»§ç»­ç¬¬ä¸€ä¸ªè‰ºæœ¯å®¶
    if num := GetVirtualSinglesTrackNumber(artist1); num != 3 {
        t.Errorf("ç¬¬ä¸‰é¦–å•æ›²åº”è¯¥æ˜¯ç¼–å· 3, å¾—åˆ° %d", num)
    }
}

func TestLimitString(t *testing.T) {
    Config.LimitMax = 10
    
    tests := []struct {
        input    string
        expected string
    }{
        {"Short", "Short"},
        {"Exactly10C", "Exactly10C"},
        {"This is a very long string", "This is a "},
        {"ä¸­æ–‡æµ‹è¯•å­—ç¬¦ä¸²å¾ˆé•¿", "ä¸­æ–‡æµ‹è¯•å­—ç¬¦ä¸²å¾ˆé•¿"[:30]}, // UTF-8å¤„ç†
    }
    
    for _, tt := range tests {
        result := LimitString(tt.input)
        if result != tt.expected {
            t.Errorf("LimitString(%q) = %q, æœŸæœ› %q", 
                tt.input, result, tt.expected)
        }
    }
}
```

2. **URLè§£ææµ‹è¯•** (`internal/parser/url_test.go`):
```go
package parser

import "testing"

func TestCheckUrl(t *testing.T) {
    tests := []struct {
        name            string
        url             string
        expectedStore   string
        expectedAlbumID string
    }{
        {
            name:            "ç¾å›½åŒºä¸“è¾‘",
            url:             "https://music.apple.com/us/album/midnights/1645684670",
            expectedStore:   "us",
            expectedAlbumID: "1645684670",
        },
        {
            name:            "ä¸­å›½åŒºä¸“è¾‘",
            url:             "https://music.apple.com/cn/album/1234567890",
            expectedStore:   "cn",
            expectedAlbumID: "1234567890",
        },
        // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            store, albumID := CheckUrl(tt.url)
            if store != tt.expectedStore || albumID != tt.expectedAlbumID {
                t.Errorf("CheckUrl() = (%q, %q), æœŸæœ› (%q, %q)", 
                    store, albumID, tt.expectedStore, tt.expectedAlbumID)
            }
        })
    }
}
```

3. **å·¥å…·å‡½æ•°æµ‹è¯•** (`internal/utils/helpers_test.go`):
```go
package utils

import (
    "os"
    "path/filepath"
    "testing"
)

func TestSafeMoveFile(t *testing.T) {
    // åˆ›å»ºä¸´æ—¶ç›®å½•
    tmpDir := t.TempDir()
    
    srcFile := filepath.Join(tmpDir, "source.txt")
    dstFile := filepath.Join(tmpDir, "dest.txt")
    
    // åˆ›å»ºæºæ–‡ä»¶
    content := []byte("test content")
    if err := os.WriteFile(srcFile, content, 0644); err != nil {
        t.Fatal(err)
    }
    
    // æµ‹è¯•ç§»åŠ¨
    if err := SafeMoveFile(srcFile, dstFile); err != nil {
        t.Errorf("SafeMoveFile() å¤±è´¥: %v", err)
    }
    
    // éªŒè¯æ–‡ä»¶å·²ç§»åŠ¨
    if _, err := os.Stat(srcFile); !os.IsNotExist(err) {
        t.Error("æºæ–‡ä»¶åº”è¯¥è¢«åˆ é™¤")
    }
    
    if _, err := os.Stat(dstFile); err != nil {
        t.Error("ç›®æ ‡æ–‡ä»¶åº”è¯¥å­˜åœ¨")
    }
    
    // éªŒè¯å†…å®¹
    got, _ := os.ReadFile(dstFile)
    if string(got) != string(content) {
        t.Errorf("æ–‡ä»¶å†…å®¹ä¸åŒ¹é…")
    }
}
```

**æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡**:
- æ ¸å¿ƒé€»è¾‘: 80%+
- å·¥å…·å‡½æ•°: 70%+
- æ•´ä½“: 60%+

**è¿è¡Œæµ‹è¯•**:
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
go test ./...

# æŸ¥çœ‹è¦†ç›–ç‡
go test -cover ./...

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

**éªŒè¯æ¸…å•**:
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] è¦†ç›–ç‡è¾¾åˆ°ç›®æ ‡
- [ ] æµ‹è¯•ç”¨ä¾‹å…¨é¢
- [ ] è¾¹ç•Œæƒ…å†µæœ‰è¦†ç›–

---

### é˜¶æ®µ 4: ä»£ç è´¨é‡æå‡ï¼ˆç¬¬4å‘¨ï¼‰

#### 8ï¸âƒ£ å®šä¹‰å¸¸é‡æ›¿æ¢é­”æ³•æ•°å­— ğŸŸ¢

**ä¼˜å…ˆçº§**: ä»£ç è´¨é‡  
**å½±å“**: ä½ | **éš¾åº¦**: ä½ | **é¢„è®¡æ—¶é—´**: 1-2å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b refactor/define-constants
```

**åˆ›å»ºå¸¸é‡æ–‡ä»¶** (`internal/constants/constants.go`):
```go
package constants

import "time"

// ==================== é‡è¯•é…ç½® ====================
const (
    // MaxRetryAttempts æ¯ä¸ªè´¦å·çš„æœ€å¤§é‡è¯•æ¬¡æ•°
    MaxRetryAttempts = 3
    
    // RetryDelayMilliseconds é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    RetryDelayMilliseconds = 1500
    
    // MaxConnectionRefusedRetries è¿æ¥è¢«æ‹’ç»çš„æœ€å¤§é‡è¯•æ¬¡æ•°
    MaxConnectionRefusedRetries = 3
)

// ==================== Token éªŒè¯ ====================
const (
    // MinTokenLength Token çš„æœ€å°é•¿åº¦
    MinTokenLength = 50
)

// ==================== ç½‘ç»œé…ç½® ====================
const (
    // DefaultHTTPTimeout HTTP è¯·æ±‚é»˜è®¤è¶…æ—¶æ—¶é—´
    DefaultHTTPTimeout = 30 * time.Second
    
    // DefaultUserAgent é»˜è®¤ç”¨æˆ·ä»£ç†
    DefaultUserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
)

// ==================== ç¼“å­˜é…ç½® ====================
const (
    // DefaultCachePath é»˜è®¤ç¼“å­˜è·¯å¾„
    DefaultCachePath = "./Cache"
    
    // DefaultBatchSize é»˜è®¤æ‰¹æ¬¡å¤§å°
    DefaultBatchSize = 20
    
    // CacheHashLength ç¼“å­˜ç›®å½•å“ˆå¸Œé•¿åº¦
    CacheHashLength = 16
)

// ==================== è·¯å¾„é•¿åº¦é™åˆ¶ ====================
const (
    // WindowsMaxPathLength Windows ç³»ç»Ÿçš„æœ€å¤§è·¯å¾„é•¿åº¦
    WindowsMaxPathLength = 255
    
    // UnixMaxPathLength Unix/Linux ç³»ç»Ÿçš„æœ€å¤§è·¯å¾„é•¿åº¦
    UnixMaxPathLength = 4096
)

// ==================== ä¸‹è½½é…ç½® ====================
const (
    // DefaultCoverSize é»˜è®¤å°é¢å°ºå¯¸
    DefaultCoverSize = "5000x5000"
    
    // DefaultChunkThreads é»˜è®¤åˆ‡ç‰‡ä¸‹è½½çº¿ç¨‹æ•°
    DefaultChunkThreads = 30
    
    // DefaultLosslessThreads é»˜è®¤æ— æŸæ ¼å¼ä¸‹è½½çº¿ç¨‹æ•°
    DefaultLosslessThreads = 5
    
    // DefaultAacThreads é»˜è®¤ AAC æ ¼å¼ä¸‹è½½çº¿ç¨‹æ•°
    DefaultAacThreads = 5
    
    // DefaultHiResThreads é»˜è®¤ Hi-Res æ ¼å¼ä¸‹è½½çº¿ç¨‹æ•°
    DefaultHiResThreads = 5
)

// ==================== å·¥ä½œ-ä¼‘æ¯å¾ªç¯ ====================
const (
    // DefaultWorkMinutes é»˜è®¤å·¥ä½œæ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    DefaultWorkMinutes = 30
    
    // DefaultRestMinutes é»˜è®¤ä¼‘æ¯æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    DefaultRestMinutes = 2
    
    // RestTickerInterval ä¼‘æ¯å€’è®¡æ—¶æ˜¾ç¤ºé—´éš”
    RestTickerInterval = 30 * time.Second
)

// ==================== éŸ³è´¨å‚æ•° ====================
var (
    // ValidAlacSampleRates æœ‰æ•ˆçš„ ALAC é‡‡æ ·ç‡
    ValidAlacSampleRates = []int{44100, 48000, 96000, 192000}
    
    // ValidAtmosBitrates æœ‰æ•ˆçš„ Atmos ç ç‡
    ValidAtmosBitrates = []int{2448, 2768}
    
    // ValidAacTypes æœ‰æ•ˆçš„ AAC ç±»å‹
    ValidAacTypes = []string{"aac-lc", "aac", "aac-binaural", "aac-downmix"}
    
    // ValidMVResolutions æœ‰æ•ˆçš„ MV åˆ†è¾¨ç‡
    ValidMVResolutions = []int{480, 720, 1080, 2160}
)

// ==================== æ–‡ä»¶ç›¸å…³ ====================
const (
    // TempFilePrefix ä¸´æ—¶æ–‡ä»¶å‰ç¼€
    TempFilePrefix = ".apple-music-tmp-"
    
    // DefaultFilePermission é»˜è®¤æ–‡ä»¶æƒé™
    DefaultFilePermission = 0644
    
    // DefaultDirPermission é»˜è®¤ç›®å½•æƒé™
    DefaultDirPermission = 0755
)
```

**æ›¿æ¢é­”æ³•æ•°å­—** - ç¤ºä¾‹ä¿®æ”¹:

1. **main.go**:
```go
// ä¹‹å‰
time.Sleep(1500 * time.Millisecond)

// ä¹‹å
import "main/internal/constants"
time.Sleep(constants.RetryDelayMilliseconds * time.Millisecond)
```

2. **downloader.go**:
```go
// ä¹‹å‰
maxRetries := 3
const maxConnectionRefusedRetries = 3

// ä¹‹å
maxRetries := constants.MaxRetryAttempts
maxConnectionRefusedRetries := constants.MaxConnectionRefusedRetries
```

3. **core/state.go**:
```go
// ä¹‹å‰
if len(accountForMV.MediaUserToken) <= 50 {
    // ...
}

// ä¹‹å
if len(accountForMV.MediaUserToken) < constants.MinTokenLength {
    // ...
}
```

**éªŒè¯æ¸…å•**:
- [ ] æ‰€æœ‰é­”æ³•æ•°å­—å·²æ›¿æ¢
- [ ] å¸¸é‡å‘½åæ¸…æ™°åˆç†
- [ ] ä»£ç ç¼–è¯‘é€šè¿‡
- [ ] åŠŸèƒ½æµ‹è¯•é€šè¿‡

---

#### 9ï¸âƒ£ å¢å¼ºé”™è¯¯ä¿¡æ¯å’Œè°ƒè¯•æ—¥å¿— ğŸŸ¢

**ä¼˜å…ˆçº§**: å¯ç»´æŠ¤æ€§  
**å½±å“**: ä¸­ | **éš¾åº¦**: ä½ | **é¢„è®¡æ—¶é—´**: 2-3å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b enhance/error-logging
```

**æ”¹è¿›æ–¹æ¡ˆ**:

1. **ä½¿ç”¨ %w åŒ…è£…é”™è¯¯** (`main.go`):
```go
// ä¹‹å‰
if albumId == "" {
    err := fmt.Errorf("æ— æ•ˆçš„URL")
    logger.Warn("æ— æ•ˆçš„URL: %s", urlRaw)
    return "", "", err
}

// ä¹‹å
if albumId == "" {
    err := fmt.Errorf("è§£æURLå¤±è´¥ [%s]: æ— æ³•æå–ä¸“è¾‘ID", urlRaw)
    logger.Warn("%v", err)
    return "", "", err
}

// åŒ…è£…åº•å±‚é”™è¯¯
meta, err := api.GetMeta(albumId, mainAccount, storefront)
if err != nil {
    return albumId, "", fmt.Errorf("è·å–ä¸“è¾‘å…ƒæ•°æ®å¤±è´¥ [albumId=%s, storefront=%s]: %w", 
        albumId, storefront, err)
}
```

2. **æ·»åŠ å…³é”®è·¯å¾„çš„ DEBUG æ—¥å¿—** (`downloader.go`):
```go
func downloadTrack(track structs.TrackData, ...) (string, error) {
    startTime := time.Now()
    
    logger.Debug("å¼€å§‹ä¸‹è½½æ›²ç›®: %s (ID: %s, Artist: %s)", 
        track.Attributes.Name, 
        track.ID, 
        track.Attributes.ArtistName)
    
    // ä¸‹è½½é€»è¾‘...
    
    fileInfo, _ := os.Stat(trackPath)
    logger.Debug("æ›²ç›®ä¸‹è½½å®Œæˆ: %s, å¤§å°: %.2f MB, è€—æ—¶: %s", 
        track.Attributes.Name, 
        float64(fileInfo.Size())/1024/1024, 
        time.Since(startTime).Round(time.Second))
    
    return trackPath, nil
}

func Rip(albumId, storefront string, ...) error {
    logger.Debug("å¼€å§‹å¤„ç†ä¸“è¾‘ [albumId=%s, storefront=%s]", albumId, storefront)
    
    // è·å–å…ƒæ•°æ®
    logger.Debug("æ­£åœ¨è·å–ä¸“è¾‘å…ƒæ•°æ®...")
    meta, err := api.GetMeta(albumId, mainAccount, storefront)
    if err != nil {
        return fmt.Errorf("è·å–å…ƒæ•°æ®å¤±è´¥: %w", err)
    }
    logger.Debug("ä¸“è¾‘å…ƒæ•°æ®è·å–æˆåŠŸ: %s - %s (%d tracks)", 
        meta.Data[0].Attributes.ArtistName,
        meta.Data[0].Attributes.Name,
        len(meta.Data[0].Relationships.Tracks.Data))
    
    // æ›´å¤šè°ƒè¯•æ—¥å¿—...
}
```

3. **è§„èŒƒæ—¥å¿—çº§åˆ«ä½¿ç”¨**:
```go
// INFO: ç”¨æˆ·å…³å¿ƒçš„é‡è¦æ“ä½œ
logger.Info("å¼€å§‹ä¸‹è½½ä¸“è¾‘: %s", albumName)
logger.Info("ä¸‹è½½å®Œæˆï¼Œä¿å­˜åˆ°: %s", savePath)

// DEBUG: å¼€å‘è°ƒè¯•ä¿¡æ¯
logger.Debug("APIè¯·æ±‚: GET %s", apiURL)
logger.Debug("å“åº”çŠ¶æ€: %d", statusCode)
logger.Debug("ç¼“å­˜å‘½ä¸­: %s", cacheKey)

// WARN: å¯æ¢å¤çš„é—®é¢˜
logger.Warn("ä½¿ç”¨å¤‡ç”¨è´¦å·é‡è¯• [%s]", accountName)
logger.Warn("è·³è¿‡ä¸å¯ç”¨çš„æ›²ç›®: %s", trackName)

// ERROR: ä¸¥é‡é”™è¯¯
logger.Error("ä¸‹è½½å¤±è´¥: %v", err)
logger.Error("æ— æ³•åˆ›å»ºç›®å½• [%s]: %v", dirPath, err)
```

4. **æ·»åŠ è¯·æ±‚/å“åº”æ—¥å¿—** (`api/client.go`):
```go
func GetMeta(albumId string, account *structs.Account, storefront string) (*structs.AutoGenerated, error) {
    apiURL := fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/albums/%s", storefront, albumId)
    
    logger.Debug("API è¯·æ±‚: GET %s", apiURL)
    logger.Debug("Headers: Authorization=Bearer ***, Media-User-Token=%s...", 
        account.MediaUserToken[:10])  // åªæ˜¾ç¤ºå‰10ä¸ªå­—ç¬¦
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, fmt.Errorf("HTTP è¯·æ±‚å¤±è´¥ [%s]: %w", apiURL, err)
    }
    defer resp.Body.Close()
    
    logger.Debug("API å“åº”: %d %s (è€—æ—¶: %s)", 
        resp.StatusCode, 
        resp.Status, 
        time.Since(startTime))
    
    // ...
}
```

**éªŒè¯æ¸…å•**:
- [ ] æ‰€æœ‰é”™è¯¯éƒ½åŒ…å«ä¸Šä¸‹æ–‡ä¿¡æ¯
- [ ] DEBUG æ—¥å¿—è¦†ç›–å…³é”®è·¯å¾„
- [ ] æ—¥å¿—çº§åˆ«ä½¿ç”¨æ­£ç¡®
- [ ] ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯
- [ ] æ—¥å¿—æ ¼å¼ç»Ÿä¸€

---

### é˜¶æ®µ 5: é•¿æœŸé‡æ„ï¼ˆç¬¬5-6å‘¨ï¼‰

#### ğŸ”Ÿ æ‹†åˆ†è¿‡é•¿å‡½æ•°å¹¶é‡æ„ ğŸ”µ

**ä¼˜å…ˆçº§**: é•¿æœŸä¼˜åŒ–  
**å½±å“**: ä¸­ | **éš¾åº¦**: é«˜ | **é¢„è®¡æ—¶é—´**: 5-7å¤©

**å®æ–½æ­¥éª¤**:
```bash
git checkout -b refactor/split-long-functions
```

**é‡æ„è®¡åˆ’**:

1. **é‡æ„ runDownloads** (`main.go`):
```go
// æ‹†åˆ†å‰ï¼šçº¦ 200 è¡Œçš„å¤§å‡½æ•°
func runDownloads(initialUrls []string, isBatch bool, ...) {
    // é¢„å¤„ç†
    // èµ·å§‹ä½ç½®
    // å·¥ä½œ-ä¼‘æ¯å¾ªç¯
    // ä¸‹è½½æ‰§è¡Œ
    // ç»Ÿè®¡è¾“å‡º
}

// æ‹†åˆ†åï¼šèŒè´£æ¸…æ™°çš„å°å‡½æ•°
func runDownloads(initialUrls []string, isBatch bool, taskFile string, notifier *progress.ProgressNotifier) {
    // 1. é¢„å¤„ç† URL
    finalUrls := preprocessURLs(initialUrls)
    
    // 2. åº”ç”¨èµ·å§‹ä½ç½®
    finalUrls, startIndex := applyStartOffset(finalUrls)
    
    // 3. æ˜¾ç¤ºä»»åŠ¡ä¿¡æ¯
    printTaskSummary(initialUrls, finalUrls, startIndex)
    
    // 4. æ‰§è¡Œä¸‹è½½
    if shouldUseWorkRestMode(isBatch, finalUrls) {
        runDownloadsWithWorkRest(finalUrls, startIndex, notifier)
    } else {
        runDownloadsSequential(finalUrls, startIndex, notifier)
    }
}

// é¢„å¤„ç† URLï¼ˆå±•å¼€è‰ºæœ¯å®¶é“¾æ¥ï¼‰
func preprocessURLs(urls []string) []string {
    var result []string
    
    for _, url := range urls {
        if strings.Contains(url, "/artist/") {
            logger.Debug("å±•å¼€è‰ºæœ¯å®¶ URL: %s", url)
            expanded := expandArtistURL(url)
            result = append(result, expanded...)
        } else {
            result = append(result, url)
        }
    }
    
    return result
}

// å±•å¼€è‰ºæœ¯å®¶ URL
func expandArtistURL(artistUrl string) []string {
    var urls []string
    
    artistAccount := &core.Config.Accounts[0]
    urlArtistName, urlArtistID, err := api.GetUrlArtistName(artistUrl, artistAccount)
    if err != nil {
        logger.Error("è·å–è‰ºæœ¯å®¶åç§°å¤±è´¥: %v", err)
        return urls
    }
    
    logger.Debug("è‰ºæœ¯å®¶: %s (ID: %s)", urlArtistName, urlArtistID)
    
    // è·å–ä¸“è¾‘
    albumUrls, err := api.CheckArtist(artistUrl, artistAccount, "albums")
    if err == nil {
        urls = append(urls, albumUrls...)
        logger.Info("ä»è‰ºæœ¯å®¶ %s æ·»åŠ äº† %d å¼ ä¸“è¾‘", urlArtistName, len(albumUrls))
    }
    
    // è·å– MV
    mvUrls, err := api.CheckArtist(artistUrl, artistAccount, "music-videos")
    if err == nil {
        urls = append(urls, mvUrls...)
        logger.Info("ä»è‰ºæœ¯å®¶ %s æ·»åŠ äº† %d ä¸ªMV", urlArtistName, len(mvUrls))
    }
    
    return urls
}

// åº”ç”¨èµ·å§‹ä½ç½®åç§»
func applyStartOffset(urls []string) ([]string, int) {
    if core.StartFrom <= 0 {
        return urls, 0
    }
    
    if core.StartFrom > len(urls) {
        logger.Warn("èµ·å§‹ä½ç½® %d è¶…è¿‡æ€»æ•° %dï¼Œä»ç¬¬ 1 ä¸ªå¼€å§‹", core.StartFrom, len(urls))
        return urls, 0
    }
    
    startIndex := core.StartFrom - 1
    logger.Info("è·³è¿‡å‰ %d ä¸ªä»»åŠ¡ï¼Œä»ç¬¬ %d ä¸ªå¼€å§‹", startIndex, core.StartFrom)
    
    return urls[startIndex:], startIndex
}

// åˆ¤æ–­æ˜¯å¦ä½¿ç”¨å·¥ä½œ-ä¼‘æ¯æ¨¡å¼
func shouldUseWorkRestMode(isBatch bool, urls []string) bool {
    return isBatch && 
           core.Config.WorkRestEnabled && 
           len(urls) > 1
}

// å·¥ä½œ-ä¼‘æ¯æ¨¡å¼ä¸‹è½½
func runDownloadsWithWorkRest(urls []string, startIndex int, notifier *progress.ProgressNotifier) {
    timer := NewWorkRestTimer(
        core.Config.WorkDurationMinutes,
        core.Config.RestDurationMinutes,
    )
    
    logger.Info("å·¥ä½œ-ä¼‘æ¯å¾ªç¯: å·¥ä½œ %d åˆ†é’Ÿ / ä¼‘æ¯ %d åˆ†é’Ÿ",
        core.Config.WorkDurationMinutes,
        core.Config.RestDurationMinutes)
    
    for i, url := range urls {
        processURL(url, nil, nil, i+1+startIndex, len(urls), notifier)
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¼‘æ¯
        if i < len(urls)-1 {
            timer.CheckAndRest(i+1, len(urls))
        }
    }
}

// é¡ºåºä¸‹è½½ï¼ˆæ— å·¥ä½œ-ä¼‘æ¯ï¼‰
func runDownloadsSequential(urls []string, startIndex int, notifier *progress.ProgressNotifier) {
    for i, url := range urls {
        processURL(url, nil, nil, i+1+startIndex, len(urls), notifier)
    }
}

// å·¥ä½œ-ä¼‘æ¯è®¡æ—¶å™¨
type WorkRestTimer struct {
    workDuration time.Duration
    restDuration time.Duration
    startTime    time.Time
}

func NewWorkRestTimer(workMinutes, restMinutes int) *WorkRestTimer {
    return &WorkRestTimer{
        workDuration: time.Duration(workMinutes) * time.Minute,
        restDuration: time.Duration(restMinutes) * time.Minute,
        startTime:    time.Now(),
    }
}

func (w *WorkRestTimer) CheckAndRest(current, total int) {
    elapsed := time.Since(w.startTime)
    
    if elapsed < w.workDuration {
        return  // è¿˜æ²¡åˆ°ä¼‘æ¯æ—¶é—´
    }
    
    // æ˜¾ç¤ºä¼‘æ¯ä¿¡æ¯
    w.displayRestInfo(current, total)
    
    // ç­‰å¾…ä¼‘æ¯ç»“æŸ
    w.waitForRest()
    
    // æ˜¾ç¤ºæ¢å¤ä¿¡æ¯
    w.displayResumeInfo()
    
    // é‡ç½®è®¡æ—¶å™¨
    w.startTime = time.Now()
}

func (w *WorkRestTimer) displayRestInfo(current, total int) {
    cyan := color.New(color.FgCyan, color.Bold)
    yellow := color.New(color.FgYellow)
    
    fmt.Println("\n" + strings.Repeat("=", 60))
    cyan.Printf("â¸ï¸  å·²å·¥ä½œ %d åˆ†é’Ÿï¼Œè¿›å…¥ä¼‘æ¯\n", int(w.workDuration.Minutes()))
    yellow.Printf("ğŸ˜´ ä¼‘æ¯ %d åˆ†é’Ÿ\n", int(w.restDuration.Minutes()))
    fmt.Printf("ğŸ“Š å·²å®Œæˆ: %d/%d\n", current, total)
    fmt.Printf("â° å½“å‰æ—¶é—´: %s\n", time.Now().Format("15:04:05"))
    fmt.Printf("â±ï¸  æ¢å¤æ—¶é—´: %s\n", time.Now().Add(w.restDuration).Format("15:04:05"))
    fmt.Println(strings.Repeat("=", 60))
}

func (w *WorkRestTimer) waitForRest() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    timer := time.NewTimer(w.restDuration)
    defer timer.Stop()
    
    restStart := time.Now()
    
    for {
        select {
        case <-timer.C:
            return  // ä¼‘æ¯ç»“æŸ
            
        case <-ticker.C:
            // æ˜¾ç¤ºå‰©ä½™æ—¶é—´
            remaining := w.restDuration - time.Since(restStart)
            if remaining > 0 {
                logger.Info("â³ ä¼‘æ¯ä¸­... å‰©ä½™: %.0fåˆ†%.0fç§’",
                    remaining.Minutes(),
                    remaining.Seconds()-remaining.Minutes()*60)
            }
        }
    }
}

func (w *WorkRestTimer) displayResumeInfo() {
    green := color.New(color.FgGreen)
    
    fmt.Println("\n" + strings.Repeat("=", 60))
    green.Printf("âœ… ä¼‘æ¯å®Œæ¯•ï¼Œç»§ç»­ä»»åŠ¡\n")
    fmt.Printf("â±ï¸  å·¥ä½œå¼€å§‹: %s\n", time.Now().Format("15:04:05"))
    fmt.Println(strings.Repeat("=", 60))
}
```

2. **é‡æ„ downloadTrackWithFallback** (`downloader.go`):
```go
// æ‹†åˆ†å‰ï¼šçº¦ 200 è¡Œçš„å¤§å‡½æ•°
func downloadTrackWithFallback(...) (string, error) {
    // è´¦å·å¾ªç¯
    // é‡è¯•é€»è¾‘
    // é”™è¯¯å¤„ç†
    // æ—¥å¿—è¾“å‡º
}

// æ‹†åˆ†å
func downloadTrackWithFallback(track structs.TrackData, ...) (string, error) {
    accounts := workingAccounts
    
    // å°è¯•æ‰€æœ‰å¯ç”¨è´¦å·
    for i := 0; i < len(accounts); i++ {
        accountIndex := (initialAccountIndex + i) % len(accounts)
        account := &accounts[accountIndex]
        
        // ä½¿ç”¨å½“å‰è´¦å·é‡è¯•ä¸‹è½½
        trackPath, err := tryDownloadWithRetry(
            track, meta, albumId, storefront,
            baseSaveFolder, finalSaveFolder,
            Codec, covPath, account,
            statusIndex, updateStatus, progressChan,
        )
        
        if err == nil {
            return trackPath, nil  // æˆåŠŸ
        }
        
        // è®°å½•é”™è¯¯ï¼Œå°è¯•ä¸‹ä¸€ä¸ªè´¦å·
        logger.Debug("è´¦å· %s ä¸‹è½½å¤±è´¥: %v", account.Name, err)
    }
    
    // æ‰€æœ‰è´¦å·éƒ½å¤±è´¥
    return "", fmt.Errorf("æ‰€æœ‰è´¦å·å°è¯•å¤±è´¥: %w", lastError)
}

// ä½¿ç”¨å•ä¸ªè´¦å·é‡è¯•ä¸‹è½½
func tryDownloadWithRetry(
    track structs.TrackData, 
    account *structs.Account,
    maxRetries int,
    statusIndex int,
    updateStatus func(int, string, func(...interface{}) string),
) (string, error) {
    yellow := color.New(color.FgYellow).SprintFunc()
    red := color.New(color.FgRed).SprintFunc()
    
    connectionRefusedCount := 0
    
    for attempt := 0; attempt <= maxRetries; attempt++ {
        // å°è¯•ä¸‹è½½
        trackPath, err := downloadTrackSilently(
            track, meta, albumId, storefront,
            baseSaveFolder, finalSaveFolder,
            Codec, covPath, account, progressChan,
        )
        
        if err == nil {
            return trackPath, nil  // æˆåŠŸ
        }
        
        // å¤„ç†ç‰¹å®šé”™è¯¯
        if shouldSkipTrack(err, &connectionRefusedCount) {
            updateStatus(statusIndex, "è¿æ¥æœåŠ¡å¤±è´¥ï¼Œå·²è·³è¿‡", red)
            return "", err
        }
        
        // æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
        if attempt < maxRetries {
            retryMsg := formatRetryMessage(err, attempt, maxRetries)
            updateStatus(statusIndex, retryMsg, yellow)
            time.Sleep(constants.RetryDelayMilliseconds * time.Millisecond)
        }
    }
    
    return "", fmt.Errorf("é‡è¯•æ¬¡æ•°å·²ç”¨å°½: %w", err)
}

// åˆ¤æ–­æ˜¯å¦åº”è¯¥è·³è¿‡æ›²ç›®
func shouldSkipTrack(err error, connectionRefusedCount *int) bool {
    if strings.Contains(err.Error(), "connection refused") {
        *connectionRefusedCount++
        if *connectionRefusedCount >= constants.MaxConnectionRefusedRetries {
            return true
        }
    }
    return false
}

// æ ¼å¼åŒ–é‡è¯•æ¶ˆæ¯
func formatRetryMessage(err error, attempt, maxRetries int) string {
    errorMsg := err.Error()
    if len(errorMsg) > 40 {
        errorMsg = errorMsg[:37] + "..."
    }
    return fmt.Sprintf("é‡è¯• %d/%d: %s", attempt+1, maxRetries+1, errorMsg)
}
```

**éªŒè¯æ¸…å•**:
- [ ] å‡½æ•°é•¿åº¦åˆç†ï¼ˆ<50è¡Œï¼‰
- [ ] èŒè´£å•ä¸€æ˜ç¡®
- [ ] ä»£ç å¯è¯»æ€§æå‡
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ€§èƒ½æ— æ˜æ˜¾ä¸‹é™

---

## ğŸ“Š è¿›åº¦è·Ÿè¸ª

| ä»»åŠ¡ | çŠ¶æ€ | å¼€å§‹æ—¥æœŸ | å®Œæˆæ—¥æœŸ | å¤‡æ³¨ |
|------|------|----------|----------|------|
| 1. ä¿®å¤èµ„æºæ³„æ¼ | â¬œ å¾…å¼€å§‹ | - | - | - |
| 2. Context å–æ¶ˆ | â¬œ å¾…å¼€å§‹ | - | - | - |
| 3. åˆä½œè‰ºæœ¯å®¶å¤„ç† | â¬œ å¾…å¼€å§‹ | - | - | - |
| 4. å·¥ä½œ-ä¼‘æ¯å¾ªç¯ | â¬œ å¾…å¼€å§‹ | - | - | - |
| 5. é…ç½®éªŒè¯ | â¬œ å¾…å¼€å§‹ | - | - | - |
| 6. RWMutex ä¼˜åŒ– | â¬œ å¾…å¼€å§‹ | - | - | - |
| 7. å•å…ƒæµ‹è¯• | â¬œ å¾…å¼€å§‹ | - | - | - |
| 8. å®šä¹‰å¸¸é‡ | â¬œ å¾…å¼€å§‹ | - | - | - |
| 9. å¢å¼ºæ—¥å¿— | â¬œ å¾…å¼€å§‹ | - | - | - |
| 10. å‡½æ•°é‡æ„ | â¬œ å¾…å¼€å§‹ | - | - | - |

**çŠ¶æ€å›¾ä¾‹**:
- â¬œ å¾…å¼€å§‹
- ğŸŸ¦ è¿›è¡Œä¸­
- âœ… å·²å®Œæˆ
- â¸ï¸ æš‚åœ
- âŒ å·²å–æ¶ˆ

---

## ğŸ”„ å·¥ä½œæµç¨‹

### æ¯ä¸ªä»»åŠ¡çš„æ ‡å‡†æµç¨‹:

1. **åˆ›å»ºå­åˆ†æ”¯**
   ```bash
   git checkout experimental/code-improvements
   git checkout -b [task-branch-name]
   ```

2. **å®æ–½æ”¹è¿›**
   - æŒ‰ç…§è®¡åˆ’ä¿®æ”¹ä»£ç 
   - æ·»åŠ å¿…è¦çš„æ³¨é‡Š
   - æ›´æ–°ç›¸å…³æ–‡æ¡£

3. **æµ‹è¯•éªŒè¯**
   - è¿è¡Œå•å…ƒæµ‹è¯•
   - æ‰§è¡ŒåŠŸèƒ½æµ‹è¯•
   - æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼ˆå¦‚é€‚ç”¨ï¼‰

4. **æäº¤ä¿®æ”¹**
   ```bash
   git add .
   git commit -m "[type]: [description]
   
   - [è¯¦ç»†è¯´æ˜1]
   - [è¯¦ç»†è¯´æ˜2]"
   ```

5. **åˆå¹¶åˆ°å®éªŒåˆ†æ”¯**
   ```bash
   git checkout experimental/code-improvements
   git merge [task-branch-name]
   ```

6. **æ›´æ–°è¿›åº¦**
   - æ›´æ–°æœ¬æ–‡æ¡£çš„è¿›åº¦è¡¨
   - æ ‡è®° TODO é¡¹ä¸ºå®Œæˆ
   - æäº¤é˜¶æ®µæ€§æ€»ç»“

### Commit Message è§„èŒƒ:

- `fix:` - ä¿®å¤ bug
- `feat:` - æ–°åŠŸèƒ½
- `refactor:` - é‡æ„
- `perf:` - æ€§èƒ½ä¼˜åŒ–
- `test:` - æ·»åŠ æµ‹è¯•
- `docs:` - æ–‡æ¡£æ›´æ–°
- `chore:` - æ„å»º/å·¥å…·é“¾æ›´æ–°

---

## ğŸ“ˆ è´¨é‡ä¿è¯

### ä»£ç å®¡æŸ¥æ£€æŸ¥ç‚¹:

- [ ] ä»£ç ç¬¦åˆ Go è¯­è¨€è§„èŒƒ
- [ ] æ²¡æœ‰å¼•å…¥æ–°çš„ linter é”™è¯¯
- [ ] æ‰€æœ‰å…¬å…±å‡½æ•°æœ‰æ–‡æ¡£æ³¨é‡Š
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ—¥å¿—è¾“å‡ºåˆç†
- [ ] æ²¡æœ‰ç¡¬ç¼–ç çš„é­”æ³•æ•°å­—/å­—ç¬¦ä¸²
- [ ] èµ„æºæ­£ç¡®é‡Šæ”¾ï¼ˆdefer, Closeï¼‰
- [ ] å¹¶å‘å®‰å…¨ï¼ˆå¦‚é€‚ç”¨ï¼‰

### æµ‹è¯•æ£€æŸ¥ç‚¹:

- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] åŠŸèƒ½æµ‹è¯•é€šè¿‡
- [ ] è¾¹ç•Œæƒ…å†µæœ‰è¦†ç›–
- [ ] æ€§èƒ½æ— æ˜æ˜¾ä¸‹é™
- [ ] å†…å­˜æ— æ³„æ¼

---

## ğŸ¯ å®Œæˆæ ‡å‡†

**å®éªŒåˆ†æ”¯å°±ç»ªæ¡ä»¶**:

1. âœ… æ‰€æœ‰ 10 é¡¹ä»»åŠ¡å®Œæˆ
2. âœ… æµ‹è¯•è¦†ç›–ç‡ â‰¥ 60%
3. âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
4. âœ… æ— å·²çŸ¥çš„ä¸¥é‡ bug
5. âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•é€šè¿‡
6. âœ… æ–‡æ¡£æ›´æ–°å®Œæˆ
7. âœ… ä»£ç å®¡æŸ¥é€šè¿‡

**åˆå¹¶åˆ°ä¸»åˆ†æ”¯å‰**:

1. âœ… å®Œæ•´çš„åŠŸèƒ½æµ‹è¯•
2. âœ… åœ¨çœŸå®ç¯å¢ƒä¸­æµ‹è¯•
3. âœ… è·å¾—ç¤¾åŒºåé¦ˆï¼ˆå¦‚é€‚ç”¨ï¼‰
4. âœ… æ›´æ–° CHANGELOG
5. âœ… å‡†å¤‡å‘å¸ƒè¯´æ˜

---

## ğŸ“ å¤‡æ³¨

- æœ¬è®¡åˆ’æ˜¯æŒ‡å¯¼æ€§çš„ï¼Œå¯æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
- é‡åˆ°é˜»å¡é—®é¢˜åŠæ—¶è®°å½•å¹¶å¯»æ±‚å¸®åŠ©
- ä¿æŒå®éªŒåˆ†æ”¯ä¸ä¸»åˆ†æ”¯çš„åŒæ­¥ï¼ˆå®šæœŸ merge mainï¼‰
- é‡å¤§ä¿®æ”¹å‰å…ˆè®¨è®ºæ–¹æ¡ˆ
- å…³æ³¨æ€§èƒ½å½±å“ï¼Œé¿å…å¼•å…¥æ€§èƒ½å›é€€

---

**æœ€åæ›´æ–°**: 2025-11-03  
**ç»´æŠ¤è€…**: å¼€å‘å›¢é˜Ÿ

